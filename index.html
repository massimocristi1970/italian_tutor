<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Italian & Sicilian Tutor</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .correct-answer-input {
            border-color: #10B981; /* Tailwind green-500 */
        }
        .pulse-animation {
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.5;
            }
        }
        /* Custom scrollbar for chat window */
        #chat-window::-webkit-scrollbar {
            width: 8px;
        }
        #chat-window::-webkit-scrollbar-thumb {
            background-color: #9CA3AF;
            border-radius: 4px;
        }
        .chat-message-user {
            background-color: #3B82F6; /* Blue-500 */
            color: white;
            align-self: flex-end;
            margin-left: auto;
            border-top-right-radius: 0.75rem;
            border-top-left-radius: 0.75rem;
            border-bottom-left-radius: 0.75rem;
        }
        .chat-message-ai {
            background-color: #F3F4F6; /* Gray-100 */
            color: #1F2937; /* Gray-800 */
            align-self: flex-start;
            margin-right: auto;
            border-top-right-radius: 0.75rem;
            border-top-left-radius: 0.75rem;
            border-bottom-right-radius: 0.75rem;
        }
        .dark .chat-message-ai {
             background-color: #4B5563; /* Gray-600 */
             color: #F9FAFB; /* Gray-50 */
        }
    </style>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- 1. CONFIGURATION (CRITICAL: MUST MATCH YOUR FIREBASE PROJECT) ---
        
        // Variables provided by the Canvas environment (will be undefined on GitHub Pages)
        const CANVAS_FIREBASE_CONFIG = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 
        
        // YOUR FIREBASE CONFIGURATION (Replaced placeholder values)
        const USER_FIREBASE_CONFIG = {
            apiKey: "AIzaSyAMlShSEWBzHhKTL6lcFYVec1U6i_kNco0", 
            authDomain: "italiantutorapp.firebaseapp.com",
            projectId: "italiantutorapp", 
            storageBucket: "italiantutorapp.firebasestorage.app",
            messagingSenderId: "915130971011",
            appId: "1:915130971011:web:171cfb69941fdf7997fcb6"
        };

        // Use Canvas config if available, otherwise use the user's hardcoded config.
        const firebaseConfig = (CANVAS_FIREBASE_CONFIG && Object.keys(CANVAS_FIREBASE_CONFIG).length > 0)
            ? CANVAS_FIREBASE_CONFIG
            : USER_FIREBASE_CONFIG;

        // Use the Firebase Project ID as the App ID for Firestore paths when running externally.
        const appId = firebaseConfig.projectId || 'default-app-id';

        // Initialize Firebase
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase Initialization Failed. Check the console for configuration errors.", e);
            app = null; auth = { currentUser: null, onAuthStateChanged: (cb) => cb(null) }; db = null;
        }
        
        // Export Firebase instances for use in the main script
        window.firebase = {
            auth,
            db,
            appId,
            initialAuthToken,
            onAuthStateChanged,
            signInAnonymously,
            signInWithCustomToken,
            doc,
            getDoc,
            setDoc,
            onSnapshot,
            collection
        };
    </script>
</head>
<body class="flex items-center justify-center min-h-screen p-4 transition-colors duration-500 bg-gray-100 dark:bg-gray-900">
    <!-- Main application container -->
    <div class="bg-white p-6 sm:p-8 rounded-xl shadow-lg w-full max-w-sm sm:max-w-lg transition-colors duration-500 dark:bg-gray-800">
        <!-- Header with language selection and user ID -->
        <div class="flex items-center justify-between mb-6 flex-wrap">
            <h1 class="text-xl sm:text-2xl font-bold text-gray-800 text-center flex-grow dark:text-gray-100">Language Tutor</h1>
            <select id="language-select" class="bg-gray-200 text-gray-800 p-2 rounded-lg cursor-pointer dark:bg-gray-700 dark:text-gray-100 mt-2 sm:mt-0">
                <option value="italian">Italian</option>
                <option value="sicilian">Sicilian</option>
            </select>
            <div id="user-id-display" class="w-full text-center text-xs text-gray-600 mt-2 truncate dark:text-gray-400">User ID: Loading...</div>
        </div>

        <!-- Mode Toggle Buttons -->
        <div class="flex justify-center space-x-4 mb-6">
            <button id="tutor-mode-btn" class="py-2 px-4 rounded-lg font-semibold bg-blue-500 text-white transition-colors duration-300">Phrase Tutor</button>
            <button id="chat-mode-btn" class="py-2 px-4 rounded-lg font-semibold bg-gray-200 text-gray-800 transition-colors duration-300 dark:bg-gray-700 dark:text-gray-100">AI Chat</button>
        </div>

        <!-- Tutor Section -->
        <div id="tutor-section" class="text-center">
            <!-- System message/alert container -->
            <div id="tutor-system-message" class="text-center font-semibold text-sm mb-4 h-6 opacity-0 transition-opacity duration-500 text-gray-800 dark:text-gray-100"></div>

            <!-- New Mastery Indicator -->
            <div id="mastery-indicator" class="text-sm font-semibold text-amber-500 mb-2 h-6"></div>

            <!-- Flashcard content -->
            <div class="h-40 sm:h-48 flex items-center justify-center bg-gray-50 rounded-lg p-4 mb-6 transition-colors duration-500 dark:bg-gray-700">
                <p id="phrase-en" class="text-lg sm:text-2xl font-medium text-gray-800 transition-opacity duration-300 dark:text-gray-100"></p>
                <p id="phrase-it" class="text-lg sm:text-2xl font-medium text-gray-800 transition-opacity duration-300 hidden dark:text-gray-100"></p>
            </div>

            <!-- Input and action buttons -->
            <div class="flex flex-col sm:flex-row items-center space-y-4 sm:space-y-0 sm:space-x-4 mb-6">
                <input id="answer-input" type="text" placeholder="Type your answer here..."
                       class="w-full sm:flex-grow p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500 transition-all duration-300 dark:bg-gray-900 dark:border-gray-600 dark:text-gray-100"
                       spellcheck="false" autocomplete="off">
                <button id="tutor-listen-btn" class="bg-gray-200 text-gray-800 p-3 rounded-lg transition-all duration-300 hover:bg-gray-300 w-1/3 sm:w-auto dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600">
                    <i class="fas fa-volume-up"></i>
                </button>
                <button id="tutor-speak-btn" class="bg-gray-200 text-gray-800 p-3 rounded-lg transition-all duration-300 hover:bg-gray-300 w-1/3 sm:w-auto relative dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600">
                    <i class="fas fa-microphone"></i>
                    <span id="tutor-listening-pulse" class="absolute inset-0 bg-red-500 rounded-full opacity-0"></span>
                </button>
            </div>

            <!-- Feedback and action buttons -->
            <div id="tutor-feedback" class="text-center text-sm font-semibold h-6 mb-4"></div>
            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
                <button id="check-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg w-full transition-all duration-300 transform hover:scale-105 shadow-md">
                    Check Answer
                </button>
                <button id="next-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-3 px-6 rounded-lg w-full transition-all duration-300 transform hover:scale-105 shadow-md hidden">
                    Next Phrase
                </button>
                <button id="reveal-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg w-full transition-all duration-300 transform hover:scale-105 shadow-md">
                    Reveal Answer
                </button>
            </div>
        </div>

        <!-- Chat Section -->
        <div id="chat-section" class="hidden flex flex-col h-[60vh] max-h-[600px] overflow-hidden">
            <div id="chat-window" class="flex-grow flex flex-col space-y-3 p-4 bg-gray-50 rounded-lg mb-4 overflow-y-auto transition-colors duration-500 dark:bg-gray-700">
                <div class="text-center text-sm text-gray-500 dark:text-gray-400">Start a conversation with the AI tutor.</div>
            </div>
            <div class="flex items-center space-x-2">
                <input id="chat-input" type="text" placeholder="Send a message..."
                       class="flex-grow p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500 transition-all duration-300 dark:bg-gray-900 dark:border-gray-600 dark:text-gray-100">
                <button id="chat-speak-btn" class="bg-gray-200 text-gray-800 p-3 rounded-lg transition-all duration-300 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600">
                    <i class="fas fa-microphone"></i>
                </button>
                <button id="chat-send-btn" class="bg-blue-500 hover:bg-blue-600 text-white p-3 rounded-lg transition-all duration-300">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import Firebase modules from the `window` object
        const { auth, db, appId, initialAuthToken, onAuthStateChanged, signInAnonymously, signInWithCustomToken, doc, getDoc, setDoc, onSnapshot, collection } = window.firebase;
        
        // --- Core Application Logic ---
        const languageSelect = document.getElementById('language-select');
        const tutorSection = document.getElementById('tutor-section');
        const chatSection = document.getElementById('chat-section');
        const tutorModeBtn = document.getElementById('tutor-mode-btn');
        const chatModeBtn = document.getElementById('chat-mode-btn');

        // Tutor section elements
        const phraseEnElement = document.getElementById('phrase-en');
        const phraseItElement = document.getElementById('phrase-it');
        const answerInput = document.getElementById('answer-input');
        const tutorListenBtn = document.getElementById('tutor-listen-btn');
        const tutorSpeakBtn = document.getElementById('tutor-speak-btn');
        const tutorListeningPulse = document.getElementById('tutor-listening-pulse');
        const checkBtn = document.getElementById('check-btn');
        const nextBtn = document.getElementById('next-btn');
        const revealBtn = document.getElementById('reveal-btn');
        const tutorFeedbackElement = document.getElementById('tutor-feedback');
        const tutorSystemMessageElement = document.getElementById('tutor-system-message');
        const userIdDisplay = document.getElementById('user-id-display');
        const masteryIndicator = document.getElementById('mastery-indicator'); // New element

        // Chat section elements
        const chatWindow = document.getElementById('chat-window');
        const chatInput = document.getElementById('chat-input');
        const chatSpeakBtn = document.getElementById('chat-speak-btn');
        const chatSendBtn = document.getElementById('chat-send-btn');
        
        const italianPhrases = [
            { en: "Hello", it: "Ciao", mastered: 0 },
            { en: "Thank you", it: "Grazie", mastered: 0 },
            { en: "Please", it: "Per favore", mastered: 0 },
            { en: "Excuse me", it: "Mi scusi", mastered: 0 },
            { en: "Yes", it: "Sì", mastered: 0 },
            { en: "No", it: "No", mastered: 0 },
            { en: "Goodbye", it: "Arrivederci", mastered: 0 },
            { en: "How are you?", it: "Come stai?", mastered: 0 },
            { en: "I don't understand", it: "Non capisco", mastered: 0 },
            { en: "Do you speak English?", it: "Parli inglese?", mastered: 0 },
            { en: "What is your name?", it: "Come ti chiami?", mastered: 0 },
            { en: "My name is...", it: "Mi chiamo...", mastered: 0 },
            { en: "Where are you from?", it: "Di dove sei?", mastered: 0 },
            { en: "I am from...", it: "Sono di...", mastered: 0 },
            { en: "I am sorry", it: "Mi dispiace", mastered: 0 },
            { en: "How much does this cost?", it: "Quanto costa?", mastered: 0 },
            { en: "The food is delicious", it: "Il cibo è delizioso", mastered: 0 },
            { en: "I would like a coffee", it: "Vorrei un caffè", mastered: 0 },
            { en: "I am tired", it: "Sono stanco/a", mastered: 0 },
            { en: "Let's go", it: "Andiamo", mastered: 0 }
        ];

        const sicilianPhrases = [
            { en: "Hello", it: "Salutu", mastered: 0 },
            { en: "Thank you", it: "Grazzî", mastered: 0 },
            { en: "Please", it: "Pi favuri", mastered: 0 },
            { en: "Excuse me", it: "M'accatti", mastered: 0 },
            { en: "Yes", it: "Sì", mastered: 0 },
            { en: "No", it: "No", mastered: 0 },
            { en: "Goodbye", it: "Addiu", mastered: 0 },
            { en: "How are you?", it: "Comu si senti?", mastered: 0 },
            { en: "I don't understand", it: "Nun capisciu", mastered: 0 },
            { en: "Do you speak English?", it: "Parra ngrisi?", mastered: 0 },
            { en: "What is your name?", it: "Comu ti chiami?", mastered: 0 },
            { en: "My name is...", it: "Mi chiàmu...", mastered: 0 },
            { en: "Where are you from?", it: "Di unni si?", mastered: 0 },
            { en: "I am from...", it: "Sugnu di...", mastered: 0 },
            { en: "I am sorry", it: "M'addulìu", mastered: 0 },
            { en: "How much does this cost?", it: "Quantu costa?", mastered: 0 },
            { en: "The food is delicious", it: "Lu manciari è diliziusu", mastered: 0 },
            { en: "I would like a coffee", it: "Vuògghiu un cafè", mastered: 0 },
            { en: "I am tired", it: "Sugnu stancu/a", mastered: 0 },
            { en: "Let's go", it: "Iemu", mastered: 0 }
        ];

        let currentPhrases = italianPhrases;
        // The structure of currentPhrase will match the static format { en, it, mastered } OR the dynamic format { en, it, topic }
        let currentPhrase = null; 
        let isAuthReady = false;
        let userId = null; 
        let isGeneratingPhrase = false;
        const masteredThreshold = 2;
        
        // Check if db is initialized before creating ref functions
        const progressDocRef = () => db && userId ? doc(db, 'artifacts', appId, 'users', userId, 'progress', 'user_progress') : null;
        const chatHistoryDocRef = () => db && userId ? doc(db, 'artifacts', appId, 'users', userId, 'chat', languageSelect.value) : null;

        // API Key and URLs
        // !!! CRITICAL FIX: IF RUNNING OUTSIDE OF CANVAS, PASTE YOUR GEMINI API KEY HERE !!!
        const API_KEY = "AIzaSyBJzBPjcCDlDaN0G2OyBrm6zwr7oLI1aUU"; // Updated with user's key
        const GEMINI_TEXT_API = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=" + API_KEY;
        const GEMINI_TTS_API = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=" + API_KEY;
        
        let chatHistory = [];
        let isWaitingForResponse = false;

        function switchMode(mode) {
            if (mode === 'tutor') {
                tutorSection.classList.remove('hidden');
                chatSection.classList.add('hidden');
                tutorModeBtn.classList.add('bg-blue-500', 'text-white');
                tutorModeBtn.classList.remove('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                chatModeBtn.classList.remove('bg-blue-500', 'text-white');
                chatModeBtn.classList.add('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                loadNextPhrase();
            } else {
                chatSection.classList.remove('hidden');
                tutorSection.classList.add('hidden');
                chatModeBtn.classList.add('bg-blue-500', 'text-white');
                chatModeBtn.classList.remove('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                tutorModeBtn.classList.remove('bg-blue-500', 'text-white');
                tutorModeBtn.classList.add('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                loadChatHistory();
            }
        }

        tutorModeBtn.addEventListener('click', () => switchMode('tutor'));
        chatModeBtn.addEventListener('click', () => switchMode('chat'));
        languageSelect.addEventListener('change', () => {
            currentPhrases = languageSelect.value === 'italian' ? italianPhrases : sicilianPhrases;
            loadProgress(); // Reload progress and chat history when language changes
            if (!tutorSection.classList.contains('hidden')) {
                loadNextPhrase();
            }
            if (!chatSection.classList.contains('hidden')) {
                loadChatHistory();
            }
        });

        // --- Firebase Auth and Data Loading ---

        /**
         * Initializes Firebase authentication (sign in or custom token sign in).
         */
        async function initializeAuth() {
            if (!auth || !db) {
                console.error("Database not initialized. Cannot authenticate.");
                userIdDisplay.textContent = "User ID: Error (DB init)";
                isAuthReady = true;
                return;
            }

            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Auth Error: ", error);
                userIdDisplay.textContent = "User ID: Auth Failed";
            }
        }

        /**
         * Loads user progress from Firestore or initializes it.
         */
        function loadProgress() {
            if (!isAuthReady || !progressDocRef()) return;

            // Load progress for the current language only
            const languageKey = languageSelect.value;

            onSnapshot(progressDocRef(), (docSnapshot) => {
                let initialLoad = true;
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    const progressData = data[languageKey] || [];

                    currentPhrases.forEach((phrase, index) => {
                        const savedPhrase = progressData.find(p => p.en === phrase.en);
                        if (savedPhrase) {
                            phrase.mastered = savedPhrase.mastered || 0;
                        } else {
                            // If a phrase is missing in saved data, ensure it is initialized to 0
                            phrase.mastered = 0;
                        }
                    });
                } else {
                    // Initialize document if it doesn't exist
                    saveProgress();
                }
                
                // Only load next phrase if we are in tutor mode and it's the initial load
                if (initialLoad && !tutorSection.classList.contains('hidden')) {
                    loadNextPhrase();
                }
                initialLoad = false;

            }, (error) => {
                console.error("Error listening to progress: ", error);
                tutorSystemMessageElement.textContent = "Error loading progress. Check console for 400 errors and Firebase Rules.";
                tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
            });
        }

        /**
         * Saves the current phrase progress to Firestore.
         */
        async function saveProgress() {
            if (!isAuthReady || !progressDocRef()) return;

            const languageKey = languageSelect.value;
            const progressData = currentPhrases.map(p => ({
                en: p.en,
                mastered: p.mastered
            }));

            try {
                // Fetch the existing document to merge the new language's progress
                const docSnap = await getDoc(progressDocRef());
                const existingData = docSnap.exists() ? docSnap.data() : {};
                
                await setDoc(progressDocRef(), { 
                    ...existingData, 
                    [languageKey]: progressData 
                }, { merge: true });

                // Provide visual feedback for saving
                tutorSystemMessageElement.textContent = "Progress saved!";
                tutorSystemMessageElement.classList.add('opacity-100', 'text-green-500');
                tutorSystemMessageElement.classList.remove('text-red-500');
                setTimeout(() => tutorSystemMessageElement.classList.remove('opacity-100'), 1500);

            } catch (error) {
                console.error("Error saving progress: ", error);
                tutorSystemMessageElement.textContent = "Error saving progress!";
                tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
                tutorSystemMessageElement.classList.remove('text-green-500');
            }
        }
        
        /**
         * Loads chat history from Firestore.
         */
        function loadChatHistory() {
            if (!isAuthReady || !chatHistoryDocRef()) return;

            // Clear existing chat window and show placeholder
            chatWindow.innerHTML = '<div class="text-center text-sm text-gray-500 dark:text-gray-400">Loading chat history...</div>';
            chatHistory = [];

            onSnapshot(chatHistoryDocRef(), (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    const messages = data.messages || [];
                    
                    // Only update the UI if the messages have actually changed
                    if (JSON.stringify(messages) !== JSON.stringify(chatHistory)) {
                        chatHistory = messages;
                        renderChatHistory();
                    }
                } else {
                    // Initialize document if it doesn't exist
                    saveChatHistory();
                }
            }, (error) => {
                console.error("Error listening to chat history: ", error);
                chatWindow.innerHTML = '<div class="text-center text-sm text-red-500">Error loading chat history.</div>';
            });
        }

        /**
         * Saves the current chat history to Firestore.
         */
        async function saveChatHistory() {
            if (!isAuthReady || !chatHistoryDocRef()) return;

            try {
                await setDoc(chatHistoryDocRef(), { messages: chatHistory }, { merge: true });
            } catch (error) {
                console.error("Error saving chat history: ", error);
            }
        }

        // Auth State Listener
        onAuthStateChanged(auth, (user) => {
            if (user) {
                userId = user.uid;
                userIdDisplay.textContent = `User ID: ${userId}`;
                isAuthReady = true;
                
                // Once authenticated, load data for both modes
                loadProgress();
                loadChatHistory();
                
            } else {
                // If not signed in (shouldn't happen with anonymous sign-in, but safe guard)
                isAuthReady = false;
                userId = null; // Ensure userId is null if user is signed out
                userIdDisplay.textContent = "User ID: Not Authenticated";
                
                if (phraseEnElement.textContent === "Loading...") {
                     phraseEnElement.textContent = currentPhrases[0].en;
                }
            }
        });

        // Start the authentication process
        initializeAuth();


        // --- Tutor Mode Logic ---

        function updateMasteryIndicator(masteryCount, isDynamic = false) {
             if (isDynamic) {
                 masteryIndicator.textContent = `Dynamic Phrase (Topic: ${currentPhrase.topic})`;
                 masteryIndicator.classList.add('text-blue-500');
                 masteryIndicator.classList.remove('text-amber-500', 'text-green-500');
                 return;
             }
             const stars = Array(masteryCount).fill('⭐').join('');
             masteryIndicator.textContent = `Mastery: ${stars} (${masteryCount}/${masteredThreshold})`;
             masteryIndicator.classList.remove('text-amber-500', 'text-green-500', 'text-blue-500');
             if (masteryCount >= masteredThreshold) {
                 masteryIndicator.classList.add('text-green-500');
             } else if (masteryCount > 0) {
                 masteryIndicator.classList.add('text-amber-500');
             }
        }

        /**
         * Uses Gemini to generate a new, dynamic flashcard phrase in JSON format.
         */
        async function generateDynamicPhrase() {
            isGeneratingPhrase = true;
            tutorSystemMessageElement.textContent = "Generating a new phrase with AI...";
            tutorSystemMessageElement.classList.add('opacity-100', 'text-blue-500');
            
            phraseEnElement.textContent = '<i class="fas fa-spinner fa-spin"></i>';
            phraseItElement.textContent = '';
            answerInput.value = '';
            
            // Disable buttons during generation
            checkBtn.disabled = true;
            revealBtn.disabled = true;
            tutorListenBtn.disabled = true;

            const languageName = languageSelect.value === 'italian' ? 'Italian' : 'Sicilian';
            const userQuery = `Generate a useful intermediate phrase in English and its accurate, idiomatic translation into ${languageName}. Also provide a short topic.`;
            
            // Structure the response to ensure we get a usable flashcard
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "englishPhrase": { "type": "STRING" },
                            "translation": { "type": "STRING" },
                            "topic": { "type": "STRING" }
                        },
                        "propertyOrdering": ["englishPhrase", "translation", "topic"]
                    }
                }
            };

            let generatedData = null;
            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const response = await fetch(GEMINI_TEXT_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && attempt < 2) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }

                    if (!response.ok) {
                        throw new Error(`API returned status ${response.status}`);
                    }

                    const result = await response.json();
                    const jsonString = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                    generatedData = JSON.parse(jsonString);
                    break;
                } catch (error) {
                    console.error("Dynamic Phrase Generation Error:", error);
                }
            }

            // Reset UI state
            checkBtn.disabled = false;
            revealBtn.disabled = false;
            tutorListenBtn.disabled = false;
            isGeneratingPhrase = false;
            tutorSystemMessageElement.classList.remove('opacity-100');

            if (generatedData && generatedData.englishPhrase && generatedData.translation) {
                currentPhrase = {
                    en: generatedData.englishPhrase,
                    it: generatedData.translation,
                    topic: generatedData.topic || 'General' // Use a default topic
                };
                
                phraseEnElement.textContent = currentPhrase.en;
                phraseItElement.textContent = currentPhrase.it;
                updateMasteryIndicator(0, true); // Indicate dynamic phrase
            } else {
                currentPhrase = { en: "Error generating phrase.", it: "Errore.", topic: "Error" };
                phraseEnElement.textContent = "Could not generate phrase. Try again or check the API key.";
                phraseItElement.textContent = currentPhrase.it;
                updateMasteryIndicator(0, true); 
                tutorSystemMessageElement.textContent = "AI Generation failed.";
                tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
            }
        }


        function loadNextPhrase() {
            if (!isAuthReady && !userId) {
                phraseEnElement.textContent = "Authenticating...";
                return;
            }
            
            // Find the least mastered static phrase (simple spaced repetition)
            const availablePhrases = currentPhrases.filter(p => p.mastered < masteredThreshold);
            
            if (availablePhrases.length === 0) {
                // All static phrases mastered, switch to AI generation
                generateDynamicPhrase();
                return;
            }

            // Simple randomization among the least mastered group
            availablePhrases.sort((a, b) => a.mastery - b.mastery);
            const lowestMastery = availablePhrases.length > 0 ? availablePhrases[0].mastered : 0;
            const pool = availablePhrases.filter(p => p.mastered === lowestMastery);

            currentPhrase = pool[Math.floor(Math.random() * pool.length)] || currentPhrases[0];
            
            phraseEnElement.textContent = currentPhrase.en;
            phraseItElement.textContent = currentPhrase.it;

            updateMasteryIndicator(currentPhrase.mastered); // Display mastery count

            // Reset UI
            answerInput.value = '';
            answerInput.classList.remove('correct-answer-input', 'border-red-500');
            phraseEnElement.classList.remove('hidden');
            phraseItElement.classList.add('hidden');
            checkBtn.classList.remove('hidden');
            revealBtn.classList.remove('hidden');
            nextBtn.classList.add('hidden');
            tutorFeedbackElement.textContent = '';
            tutorSystemMessageElement.classList.remove('opacity-100');
        }

        function checkAnswer() {
            if (isGeneratingPhrase) return;

            const userAnswer = answerInput.value.trim().toLowerCase().replace(/[^a-z0-9]/g, '');
            const correctAnswer = currentPhrase.it.trim().toLowerCase().replace(/[^a-z0-9]/g, '');

            if (userAnswer === correctAnswer) {
                tutorFeedbackElement.textContent = 'Correct! Molto bene!';
                tutorFeedbackElement.classList.add('text-green-500');
                tutorFeedbackElement.classList.remove('text-red-500', 'text-blue-500');
                
                answerInput.classList.add('correct-answer-input');
                answerInput.classList.remove('border-red-500');
                
                // Only update and save progress for STATIC phrases
                if (currentPhrase.mastered !== undefined) {
                    currentPhrase.mastered = (currentPhrase.mastered || 0) + 1;
                    saveProgress();
                    updateMasteryIndicator(currentPhrase.mastered); // Update indicator immediately
                }
                
                // Show Next button
                checkBtn.classList.add('hidden');
                revealBtn.classList.add('hidden');
                nextBtn.classList.remove('hidden');
            } else {
                tutorFeedbackElement.textContent = 'Incorrect. Try again!';
                tutorFeedbackElement.classList.add('text-red-500');
                tutorFeedbackElement.classList.remove('text-green-500', 'text-blue-500');
                answerInput.classList.add('border-red-500');
                answerInput.classList.remove('correct-answer-input');
            }
        }

        function revealAnswer() {
            phraseEnElement.classList.add('hidden');
            phraseItElement.classList.remove('hidden');
            checkBtn.classList.add('hidden');
            revealBtn.classList.add('hidden');
            nextBtn.classList.remove('hidden');
            tutorFeedbackElement.textContent = `The correct answer is: ${currentPhrase.it}`;
            tutorFeedbackElement.classList.add('text-blue-500');
            tutorFeedbackElement.classList.remove('text-red-500', 'text-green-500');
        }
        
        // TTS Utility functions (PCM to WAV conversion)
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcm16.byteLength;
            const fileSize = 44 + dataSize;
            
            const buffer = new ArrayBuffer(fileSize);
            const view = new DataView(buffer);
            let offset = 0;

            // RIFF chunk
            view.setUint32(offset, 0x52494646, false); offset += 4; // "RIFF"
            view.setUint32(offset, fileSize - 8, true); offset += 4; // file size
            view.setUint32(offset, 0x57415645, false); offset += 4; // "WAVE"

            // fmt chunk
            view.setUint32(offset, 0x666d7420, false); offset += 4; // "fmt "
            view.setUint32(offset, 16, true); offset += 4; // chunk size
            view.setUint16(offset, 1, true); offset += 2; // format (PCM)
            view.setUint16(offset, numChannels, true); offset += 2; // channels
            view.setUint32(offset, sampleRate, true); offset += 4; // sample rate
            view.setUint32(offset, byteRate, true); offset += 4; // byte rate
            view.setUint16(offset, blockAlign, true); offset += 2; // block align
            view.setUint16(offset, bitsPerSample, true); offset += 2; // bits per sample

            // data chunk
            view.setUint32(offset, 0x64617461, false); offset += 4; // "data"
            view.setUint32(offset, dataSize, true); offset += 4; // data size
            
            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        /**
         * Converts TTS API response (PCM) into playable audio.
         */
        function ttsToAudio(audioData, mimeType) {
            if (!audioData || !mimeType) {
                console.error("Missing audio data or mime type.");
                return;
            }

            const match = mimeType.match(/rate=(\d+)/);
            const sampleRate = match ? parseInt(match[1], 10) : 24000; // Default to 24000 if rate not found

            const pcmData = base64ToArrayBuffer(audioData);
            const pcm16 = new Int16Array(pcmData);
            const wavBlob = pcmToWav(pcm16, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);

            const audio = new Audio(audioUrl);
            audio.play().catch(e => console.error("Error playing audio:", e));
        }

        // TTS Function for Tutor Mode
        async function fetchTutorTTS(text) {
            tutorListenBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            tutorListenBtn.disabled = true;

            const language = languageSelect.value;
            // Using different voices for Italian vs Sicilian
            const voiceName = language === 'italian' ? 'Kore' : 'Charon'; 
            
            // API Key check
            if (!API_KEY && typeof __app_id === 'undefined') { // If not in canvas and key is missing
                 tutorSystemMessageElement.textContent = "AI Key Missing. Cannot play audio.";
                 tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
                 setTimeout(() => tutorSystemMessageElement.classList.remove('opacity-100'), 3000);
                 tutorListenBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                 tutorListenBtn.disabled = false;
                 return;
            }

            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: text }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: voiceName }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetch(GEMINI_TTS_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && attempt < 2) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }

                    if (!response.ok) {
                        throw new Error(`API returned status ${response.status}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType) {
                        ttsToAudio(audioData, mimeType);
                    } else {
                        throw new Error("TTS response missing audio data.");
                    }
                    
                    break; // Success
                } catch (error) {
                    console.error("TTS Fetch Error:", error);
                    if (attempt === 2) {
                        tutorSystemMessageElement.textContent = "Error playing audio.";
                        tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
                    }
                }
            }

            tutorListenBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
            tutorListenBtn.disabled = false;
        }


        // Event Listeners for Tutor Mode
        checkBtn.addEventListener('click', checkAnswer);
        nextBtn.addEventListener('click', loadNextPhrase);
        revealBtn.addEventListener('click', revealAnswer);
        tutorListenBtn.addEventListener('click', () => {
            if (!currentPhrase) return;
            // If it's a dynamic phrase, the content is in currentPhrase.it
            const textToSpeak = currentPhrase.it;
            fetchTutorTTS(textToSpeak);
        });
        
        // --- Speech Recognition (Simulated in this environment) ---
        tutorSpeakBtn.addEventListener('click', () => {
             tutorSystemMessageElement.textContent = "Speech input is not available in this environment. Please type your answer.";
             tutorSystemMessageElement.classList.add('opacity-100', 'text-orange-500');
             setTimeout(() => tutorSystemMessageElement.classList.remove('opacity-100'), 3000);
        });

        // --- Chat Mode Logic ---

        function renderChatMessage(role, text) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('max-w-[80%]', 'p-3', 'rounded-xl', 'shadow-sm', 'break-words');

            if (role === 'user') {
                messageDiv.classList.add('chat-message-user');
            } else if (role === 'model') {
                messageDiv.classList.add('chat-message-ai');
            } else if (role === 'system') {
                messageDiv.classList.add('text-center', 'text-xs', 'text-gray-500', 'dark:text-gray-400', 'w-full');
            }

            messageDiv.textContent = text;
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function renderChatHistory() {
            chatWindow.innerHTML = '';
            if (chatHistory.length === 0) {
                 chatWindow.innerHTML = '<div class="text-center text-sm text-gray-500 dark:text-gray-400">Start a conversation with the AI tutor.</div>';
                 return;
            }
            chatHistory.forEach(message => {
                renderChatMessage(message.role, message.parts[0].text);
            });
        }
        
        async function sendChat() {
            if (isWaitingForResponse) return;
            const userQuery = chatInput.value.trim();
            if (!userQuery) return;

            // API Key check for chat
            if (!API_KEY && typeof __app_id === 'undefined') {
                renderChatMessage('system', "AI Chat Failed: Missing Google Gemini API Key. Please update the API_KEY variable in the script.");
                return;
            }

            chatInput.value = '';
            
            // Add user message to history and render
            const userMessage = { role: "user", parts: [{ text: userQuery }] };
            chatHistory.push(userMessage);
            renderChatMessage('user', userQuery);
            
            isWaitingForResponse = true;
            chatSendBtn.disabled = true;
            chatSendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            
            // System instruction tailored to the selected language
            const language = languageSelect.value;
            const systemPrompt = `You are a helpful, enthusiastic, and patient language tutor specializing in ${language}. Keep your responses friendly, encouraging, and concise. Only respond in English, but use and teach ${language} phrases relevant to the user's question.`;

            // Construct payload for Gemini API
            const payload = {
                contents: chatHistory,
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };
            
            // Exponential backoff retry logic
            let modelResponseText = "Sorry, I couldn't get a response from the tutor. This usually means the Gemini API Key is missing or invalid.";
            
            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const response = await fetch(GEMINI_TEXT_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && attempt < 2) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    
                    if (!response.ok) {
                        // Check for common failure codes like 403/400 (API key issues)
                        const errorBody = await response.json();
                        console.error("Gemini API Error Body:", errorBody);
                        if (response.status >= 400 && response.status < 500) {
                             modelResponseText = "AI Chat Failed: Check if your Google Gemini API Key is valid and enabled for the model.";
                        }
                        throw new Error(`API returned status ${response.status}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];
                    modelResponseText = candidate?.content?.parts?.[0]?.text || modelResponseText;
                    
                    break; // Success
                } catch (error) {
                    console.error("Gemini Chat Fetch Error:", error);
                }
            }

            // Add model response to history and render
            const modelMessage = { role: "model", parts: [{ text: modelResponseText }] };
            chatHistory.push(modelMessage);
            renderChatMessage('model', modelResponseText);
            
            // Save updated history
            saveChatHistory();

            // Reset state
            isWaitingForResponse = false;
            chatSendBtn.disabled = false;
            chatSendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
        }

        chatSendBtn.addEventListener('click', sendChat);
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                sendChat();
            }
        });
        
        // TTS for Chat Mode (reads the last model response)
        chatSpeakBtn.addEventListener('click', () => {
            if (isWaitingForResponse || chatHistory.length === 0) return;
            
            // Find the last model message
            const lastModelMessage = [...chatHistory].reverse().find(m => m.role === 'model');
            if (lastModelMessage) {
                const textToSpeak = lastModelMessage.parts[0].text;
                const voiceName = languageSelect.value === 'italian' ? 'Leda' : 'Umbriel';

                fetchChatTTS(textToSpeak, voiceName);
            }
        });

        async function fetchChatTTS(text, voiceName) {
            chatSpeakBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            chatSpeakBtn.disabled = true;
            
            // API Key check
            if (!API_KEY && typeof __app_id === 'undefined') { 
                 renderChatMessage('system', "AI TTS Failed: Missing Google Gemini API Key.");
                 chatSpeakBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                 chatSpeakBtn.disabled = false;
                 return;
            }

            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: `Say in a friendly, encouraging tone: ${text}` }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: voiceName }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetch(GEMINI_TTS_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && attempt < 2) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }

                    if (!response.ok) {
                        throw new Error(`API returned status ${response.status}`);
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType) {
                        ttsToAudio(audioData, mimeType);
                    } else {
                        throw new Error("TTS response missing audio data.");
                    }
                    
                    break; // Success
                } catch (error) {
                    console.error("Chat TTS Fetch Error:", error);
                }
            }
            
            chatSpeakBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            chatSpeakBtn.disabled = false;
        }

        // --- Initial Load ---
        window.onload = () => {
            currentPhrases = languageSelect.value === 'italian' ? italianPhrases : sicilianPhrases;
            phraseEnElement.textContent = "Loading...";
        };

    </script>
</body>
</html>