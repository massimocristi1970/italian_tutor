<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Italian & Sicilian Tutor</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .correct-answer-input {
            border-color: #10B981; /* Tailwind green-500 */
        }
        .pulse-animation {
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.5;
            }
        }
        /* Custom scrollbar for chat window */
        #chat-window::-webkit-scrollbar {
            width: 8px;
        }
        #chat-window::-webkit-scrollbar-thumb {
            background-color: #9CA3AF;
            border-radius: 4px;
        }
        .chat-message-user {
            background-color: #3B82F6; /* Blue-500 */
            color: white;
            align-self: flex-end;
            margin-left: auto;
            border-top-right-radius: 0.75rem;
            border-top-left-radius: 0.75rem;
            border-bottom-left-radius: 0.75rem;
        }
        .chat-message-ai {
            background-color: #F3F4F6; /* Gray-100 */
            color: #1F2937; /* Gray-800 */
            align-self: flex-start;
            margin-right: auto;
            border-top-right-radius: 0.75rem;
            border-top-left-radius: 0.75rem;
            border-bottom-right-radius: 0.75rem;
        }
        .dark .chat-message-ai {
             background-color: #4B5563; /* Gray-600 */
             color: #F9FAFB; /* Gray-50 */
        }
        .progress-bar-fill {
            transition: width 0.5s ease-in-out;
        }
    </style>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- 1. CONFIGURATION (CRITICAL: MUST MATCH YOUR FIREBASE PROJECT) ---
        
        // Variables provided by the Canvas environment (will be undefined on GitHub Pages)
        const CANVAS_FIREBASE_CONFIG = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 
        
        // YOUR FIREBASE CONFIGURATION (Replaced placeholder values)
        const USER_FIREBASE_CONFIG = {
            apiKey: "AIzaSyAMlShSEWBzHhKTL6lcFYVec1U6i_kNco0", 
            authDomain: "italiantutorapp.firebaseapp.com",
            projectId: "italiantutorapp", 
            storageBucket: "italiantutorapp.firebasestorage.app",
            messagingSenderId: "915130971011",
            appId: "1:915130971011:web:171cfb69941fdf7997fcb6"
        };

        // Use Canvas config if available, otherwise use the user's hardcoded config.
        const firebaseConfig = (CANVAS_FIREBASE_CONFIG && Object.keys(CANVAS_FIREBASE_CONFIG).length > 0)
            ? CANVAS_FIREBASE_CONFIG
            : USER_FIREBASE_CONFIG;

        // Use the Firebase Project ID as the App ID for Firestore paths when running externally.
        const appId = firebaseConfig.projectId || 'default-app-id';

        // Initialize Firebase
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase Initialization Failed. Check the console for configuration errors.", e);
            app = null; auth = { currentUser: null, onAuthStateChanged: (cb) => cb(null) }; db = null;
        }
        
        // Export Firebase instances for use in the main script
        window.firebase = {
            auth,
            db,
            appId,
            initialAuthToken,
            onAuthStateChanged,
            signInAnonymously,
            signInWithCustomToken,
            doc,
            getDoc,
            setDoc,
            onSnapshot,
            collection
        };
    </script>
</head>
<body class="flex items-center justify-center min-h-screen p-4 transition-colors duration-500 bg-gray-100 dark:bg-gray-900">
    <!-- Main application container -->
    <div class="bg-white p-6 sm:p-8 rounded-xl shadow-lg w-full max-w-sm sm:max-w-lg transition-colors duration-500 dark:bg-gray-800">
        <!-- Header with language selection and user ID -->
        <div class="flex items-center justify-between mb-6 flex-wrap">
            <h1 class="text-xl sm:text-2xl font-bold text-gray-800 text-center flex-grow dark:text-gray-100 flex items-center justify-center">
                <!-- Dynamic Flag/Indicator -->
                <span id="language-flag" class="mr-2 text-2xl">ðŸ‡®ðŸ‡¹</span>
                <span id="app-title">Language Tutor</span>
            </h1>
            <select id="language-select" class="bg-gray-200 text-gray-800 p-2 rounded-lg cursor-pointer dark:bg-gray-700 dark:text-gray-100 mt-2 sm:mt-0">
                <option value="italian">Italian</option>
                <option value="sicilian">Sicilian</option>
            </select>
            <div id="user-id-display" class="w-full text-center text-xs text-gray-600 mt-2 truncate dark:text-gray-400">User ID: Loading...</div>
        </div>

        <!-- Mode Toggle Buttons -->
        <div class="flex justify-center space-x-4 mb-6">
            <button id="tutor-mode-btn" class="py-2 px-4 rounded-lg font-semibold bg-blue-500 text-white transition-colors duration-300">Phrase Tutor</button>
            <button id="chat-mode-btn" class="py-2 px-4 rounded-lg font-semibold bg-gray-200 text-gray-800 transition-colors duration-300 dark:bg-gray-700 dark:text-gray-100">AI Chat</button>
        </div>

        <!-- Tutor Section -->
        <div id="tutor-section" class="text-center">
            
            <!-- Overall Level and Progress Bar -->
            <div id="overall-progress-container" class="mb-6 bg-gray-50 p-3 rounded-lg shadow-inner dark:bg-gray-700">
                <div class="flex justify-between items-center mb-1">
                    <span id="overall-level" class="text-sm font-semibold text-gray-800 dark:text-gray-100">Level: Beginner</span>
                    <span id="progress-percent" class="text-sm font-semibold text-gray-600 dark:text-gray-300">0%</span>
                </div>
                <div class="w-full bg-gray-300 rounded-full h-2.5 dark:bg-gray-600">
                    <div id="progress-bar-fill" class="progress-bar-fill bg-green-500 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>

            <!-- System message/alert container -->
            <div id="tutor-system-message" class="text-center font-semibold text-sm mb-4 h-6 opacity-0 transition-opacity duration-500 text-gray-800 dark:text-gray-100"></div>

            <!-- Current Phrase Mastery Indicator -->
            <div id="mastery-indicator" class="text-sm font-semibold text-amber-500 mb-2 h-6"></div>

            <!-- Flashcard content -->
            <div class="h-40 sm:h-48 flex items-center justify-center bg-gray-50 rounded-lg p-4 mb-6 transition-colors duration-500 dark:bg-gray-700">
                <p id="phrase-prompt" class="absolute top-2 left-4 text-xs font-medium text-gray-500 dark:text-gray-400"></p>
                <p id="phrase-en" class="text-lg sm:text-2xl font-medium text-gray-800 transition-opacity duration-300 dark:text-gray-100"></p>
                <p id="phrase-it" class="text-lg sm:text-2xl font-medium text-gray-800 transition-opacity duration-300 hidden dark:text-gray-100"></p>
            </div>

            <!-- Input and action buttons -->
            <div class="flex flex-col sm:flex-row items-center space-y-4 sm:space-y-0 sm:space-x-4 mb-6">
                <input id="answer-input" type="text" placeholder="Type your answer here..."
                       class="w-full sm:flex-grow p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500 transition-all duration-300 dark:bg-gray-900 dark:border-gray-600 dark:text-gray-100"
                       spellcheck="false" autocomplete="off">
                <button id="tutor-listen-btn" class="bg-gray-200 text-gray-800 p-3 rounded-lg transition-all duration-300 hover:bg-gray-300 w-1/3 sm:w-auto dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600">
                    <i class="fas fa-volume-up"></i>
                </button>
                <button id="tutor-speak-btn" class="bg-gray-200 text-gray-800 p-3 rounded-lg transition-all duration-300 hover:bg-gray-300 w-1/3 sm:w-auto relative dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600">
                    <i class="fas fa-microphone"></i>
                    <span id="tutor-listening-pulse" class="absolute inset-0 bg-red-500 rounded-full opacity-0"></span>
                </button>
            </div>

            <!-- Feedback and action buttons -->
            <div id="tutor-feedback" class="text-center text-sm font-semibold h-6 mb-4"></div>
            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
                <button id="check-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg w-full transition-all duration-300 transform hover:scale-105 shadow-md">
                    Check Answer
                </button>
                <button id="next-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-3 px-6 rounded-lg w-full transition-all duration-300 transform hover:scale-105 shadow-md hidden">
                    Next Phrase
                </button>
                <button id="reveal-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg w-full transition-all duration-300 transform hover:scale-105 shadow-md">
                    Reveal Answer
                </button>
            </div>
        </div>

        <!-- Chat Section -->
        <div id="chat-section" class="hidden flex flex-col h-[60vh] max-h-[600px] overflow-hidden">
            <div id="chat-window" class="flex-grow flex flex-col space-y-3 p-4 bg-gray-50 rounded-lg mb-4 overflow-y-auto transition-colors duration-500 dark:bg-gray-700">
                <div class="text-center text-sm text-gray-500 dark:text-gray-400">Start a conversation with the AI tutor.</div>
            </div>
            <div class="flex items-center space-x-2">
                <input id="chat-input" type="text" placeholder="Send a message..."
                       class="flex-grow p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500 transition-all duration-300 dark:bg-gray-900 dark:border-gray-600 dark:text-gray-100">
                <button id="chat-speak-btn" class="bg-gray-200 text-gray-800 p-3 rounded-lg transition-all duration-300 hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600">
                    <i class="fas fa-microphone"></i>
                </button>
                <button id="chat-send-btn" class="bg-blue-500 hover:bg-blue-600 text-white p-3 rounded-lg transition-all duration-300">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import Firebase modules from the `window` object
        const { auth, db, appId, initialAuthToken, onAuthStateChanged, signInAnonymously, signInWithCustomToken, doc, getDoc, setDoc, onSnapshot, collection } = window.firebase;
        
        // --- Core Application Logic ---
        const languageSelect = document.getElementById('language-select');
        const tutorSection = document.getElementById('tutor-section');
        const chatSection = document.getElementById('chat-section');
        const tutorModeBtn = document.getElementById('tutor-mode-btn');
        const chatModeBtn = document.getElementById('chat-mode-btn');

        // Tutor section elements
        const phraseEnElement = document.getElementById('phrase-en');
        const phraseItElement = document.getElementById('phrase-it');
        const phrasePromptElement = document.getElementById('phrase-prompt');
        const answerInput = document.getElementById('answer-input');
        const tutorListenBtn = document.getElementById('tutor-listen-btn');
        const tutorSpeakBtn = document.getElementById('tutor-speak-btn');
        const checkBtn = document.getElementById('check-btn');
        const nextBtn = document.getElementById('next-btn');
        const revealBtn = document.getElementById('reveal-btn');
        const tutorFeedbackElement = document.getElementById('tutor-feedback');
        const tutorSystemMessageElement = document.getElementById('tutor-system-message');
        const userIdDisplay = document.getElementById('user-id-display');
        const masteryIndicator = document.getElementById('mastery-indicator');
        
        // Progress elements
        const overallLevelElement = document.getElementById('overall-level');
        const progressPercentElement = document.getElementById('progress-percent');
        const progressBarFillElement = document.getElementById('progress-bar-fill');
        
        // Header elements for flag update
        const languageFlag = document.getElementById('language-flag');
        const appTitle = document.getElementById('app-title');

        // Chat section elements
        const chatWindow = document.getElementById('chat-window');
        const chatInput = document.getElementById('chat-input');
        const chatSpeakBtn = document.getElementById('chat-speak-btn');
        const chatSendBtn = document.getElementById('chat-send-btn');
        
        const initialPhrases = [
            { en: "Hello", it: "Ciao", mastered: 0 },
            { en: "Thank you", it: "Grazie", mastered: 0 },
            { en: "Please", it: "Per favore", mastered: 0 },
            { en: "Excuse me", it: "Mi scusi", mastered: 0 },
            { en: "Yes", it: "SÃ¬", mastered: 0 },
            { en: "No", it: "No", mastered: 0 },
            { en: "Goodbye", it: "Arrivederci", mastered: 0 },
            { en: "How are you?", it: "Come stai?", mastered: 0 },
            { en: "I don't understand", it: "Non capisco", mastered: 0 },
            { en: "Do you speak English?", it: "Parli inglese?", mastered: 0 },
            { en: "What is your name?", it: "Come ti chiami?", mastered: 0 },
            { en: "My name is...", it: "Mi chiamo...", mastered: 0 },
            { en: "Where are you from?", it: "Di dove sei?", mastered: 0 },
            { en: "I am from...", it: "Sono di...", mastered: 0 },
            { en: "I am sorry", it: "Mi dispiace", mastered: 0 },
            { en: "How much does this cost?", it: "Quanto costa?", mastered: 0 },
            { en: "The food is delicious", it: "Il cibo Ã¨ delizioso", mastered: 0 },
            { en: "I would like a coffee", it: "Vorrei un caffÃ¨", mastered: 0 },
            { en: "I am tired", it: "Sono stanco/a", mastered: 0 },
            { en: "Let's go", it: "Andiamo", mastered: 0 }
        ];

        // Deep copies of the initial phrase lists for separation
        const italianPhrases = JSON.parse(JSON.stringify(initialPhrases));
        const sicilianPhrases = initialPhrases.map(p => {
             // Sicily-specific translations are initialized with 0 mastery
             const sicilianTranslations = {
                 "Hello": "Salutu", "Thank you": "GrazzÃ®", "Please": "Pi favuri",
                 "Excuse me": "M'accatti", "Goodbye": "Addiu", "How are you?": "Comu si senti?",
                 "I don't understand": "Nun capisciu", "Do you speak English?": "Parra ngrisi?",
                 "I am sorry": "M'addulÃ¬u", "The food is delicious": "Lu manciari Ã¨ diliziusu",
                 "I would like a coffee": "VuÃ²gghiu un cafÃ¨", "I am tired": "Sugnu stancu/a",
                 "Let's go": "Iemu",
             };
             return { 
                 ...p, 
                 it: sicilianTranslations[p.en] || p.it,
                 mastered: 0
             };
        });

        let currentPhrases = italianPhrases;
        let currentPhrase = null; 
        let isAuthReady = false;
        let userId = null; 
        let isGeneratingPhrase = false;
        
        // RAISED DIFFICULTY: Mastery threshold increased to 5
        const masteredThreshold = 5;
        const totalStaticPhrases = initialPhrases.length;
        const maxMasteryPoints = totalStaticPhrases * masteredThreshold; // Max 100 points (20 phrases * 5)

        const progressDocRef = () => db && userId ? doc(db, 'artifacts', appId, 'users', userId, 'progress', 'user_progress') : null;
        const chatHistoryDocRef = () => db && userId ? doc(db, 'artifacts', appId, 'users', userId, 'chat', languageSelect.value) : null;

        // API Key and URLs
        const API_KEY = ""; // Intentionally empty for Canvas runtime
        const GEMINI_TEXT_API = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=" + API_KEY;
        const GEMINI_TTS_API = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=" + API_KEY;
        
        let chatHistory = [];
        let isWaitingForResponse = false;
        let isReverseChallenge = false; // New state for contextual challenge

        function updateFlagDisplay(language) {
            if (language === 'italian') {
                languageFlag.textContent = 'ðŸ‡®ðŸ‡¹';
                appTitle.textContent = 'Language Tutor';
            } else if (language === 'sicilian') {
                languageFlag.textContent = 'ðŸ›ï¸'; 
                appTitle.textContent = 'Sicilian Tutor';
            }
        }
        
        function switchMode(mode) {
            if (mode === 'tutor') {
                tutorSection.classList.remove('hidden');
                chatSection.classList.add('hidden');
                tutorModeBtn.classList.add('bg-blue-500', 'text-white');
                tutorModeBtn.classList.remove('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                chatModeBtn.classList.remove('bg-blue-500', 'text-white');
                chatModeBtn.classList.add('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                loadNextPhrase();
                // Ensure progress is visible in tutor mode
                calculateOverallProgress(); 
            } else {
                chatSection.classList.remove('hidden');
                tutorSection.classList.add('hidden');
                chatModeBtn.classList.add('bg-blue-500', 'text-white');
                chatModeBtn.classList.remove('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                tutorModeBtn.classList.remove('bg-blue-500', 'text-white');
                tutorModeBtn.classList.add('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                loadChatHistory();
            }
        }

        tutorModeBtn.addEventListener('click', () => switchMode('tutor'));
        chatModeBtn.addEventListener('click', () => switchMode('chat'));
        languageSelect.addEventListener('change', () => {
            const selectedLanguage = languageSelect.value;
            currentPhrases = selectedLanguage === 'italian' ? italianPhrases : sicilianPhrases;
            updateFlagDisplay(selectedLanguage); 
            loadProgress(); 
            if (!tutorSection.classList.contains('hidden')) {
                loadNextPhrase();
            }
            if (!chatSection.classList.contains('hidden')) {
                loadChatHistory();
            }
        });

        // --- Firebase Auth and Data Loading ---
        async function initializeAuth() {
            if (!auth || !db) {
                console.error("Database not initialized. Cannot authenticate.");
                userIdDisplay.textContent = "User ID: Error (DB init)";
                isAuthReady = true;
                return;
            }

            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Auth Error: ", error);
                userIdDisplay.textContent = "User ID: Auth Failed";
            }
        }

        /**
         * Calculates total mastery points and updates the overall progress UI.
         */
        function calculateOverallProgress() {
            if (!currentPhrases || currentPhrases.length === 0) return;

            // 1. Calculate Total Mastery Points Earned
            let totalMasteryEarned = 0;
            const masteredPhrasesCount = currentPhrases.filter(p => p.mastered >= masteredThreshold).length;

            currentPhrases.forEach(phrase => {
                // Sum up actual mastered count, capped at the threshold (5)
                totalMasteryEarned += Math.min(phrase.mastered, masteredThreshold);
            });

            // 2. Calculate Percentage
            const progressPercent = Math.min(100, Math.round((totalMasteryEarned / maxMasteryPoints) * 100));
            const levelName = getLevelName(totalMasteryEarned);
            
            // 3. Update UI
            progressBarFillElement.style.width = `${progressPercent}%`;
            progressPercentElement.textContent = `${progressPercent}%`;
            overallLevelElement.textContent = `Level: ${levelName}`;
            
            // Highlight bar if progress is high
            if (progressPercent === 100) {
                 progressBarFillElement.classList.add('bg-blue-500');
                 progressBarFillElement.classList.remove('bg-green-500');
            } else {
                 progressBarFillElement.classList.add('bg-green-500');
                 progressBarFillElement.classList.remove('bg-blue-500');
            }
        }
        
        function getLevelName(masteryPoints) {
            // Milestones adjusted for maxMasteryPoints (100)
            if (masteryPoints >= 95) return "Mastery Achieved";
            if (masteryPoints >= 70) return "Advanced Learner";
            if (masteryPoints >= 40) return "Intermediate";
            if (masteryPoints >= 15) return "Novice";
            return "Beginner";
        }

        function loadProgress() {
            if (!isAuthReady || !progressDocRef()) return;

            const languageKey = languageSelect.value;
            
            // Use onSnapshot to listen for real-time updates
            onSnapshot(progressDocRef(), (docSnapshot) => {
                let initialLoad = true;
                
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    const progressData = data[languageKey] || [];

                    currentPhrases.forEach((phrase) => {
                        const savedPhrase = progressData.find(p => p.en === phrase.en);
                        phrase.mastered = savedPhrase ? (savedPhrase.mastered || 0) : 0;
                    });
                } else {
                    saveProgress(); // Initialize if not exists
                }
                
                calculateOverallProgress(); // Always update progress bar on data load
                
                // Only load next phrase if we are in tutor mode
                if (initialLoad && !tutorSection.classList.contains('hidden')) {
                    loadNextPhrase();
                }
                initialLoad = false;

            }, (error) => {
                console.error("Error listening to progress: ", error);
                tutorSystemMessageElement.textContent = "Error loading progress. Check console for 400 errors and Firebase Rules.";
                tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
            });
        }

        async function saveProgress() {
            if (!isAuthReady || !progressDocRef()) return;

            const languageKey = languageSelect.value;
            // Only save the necessary data (en and mastered count)
            const progressData = currentPhrases.map(p => ({
                en: p.en,
                mastered: p.mastered
            }));

            try {
                const docSnap = await getDoc(progressDocRef());
                const existingData = docSnap.exists() ? docSnap.data() : {};
                
                await setDoc(progressDocRef(), { 
                    ...existingData, 
                    [languageKey]: progressData 
                }, { merge: true });

                tutorSystemMessageElement.textContent = "Progress saved!";
                tutorSystemMessageElement.classList.add('opacity-100', 'text-green-500');
                setTimeout(() => tutorSystemMessageElement.classList.remove('opacity-100'), 1500);

            } catch (error) {
                console.error("Error saving progress: ", error);
                tutorSystemMessageElement.textContent = "Error saving progress!";
                tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
            }
        }
        
        function loadChatHistory() {
            if (!isAuthReady || !chatHistoryDocRef()) return;

            chatWindow.innerHTML = '<div class="text-center text-sm text-gray-500 dark:text-gray-400">Loading chat history...</div>';
            chatHistory = [];

            onSnapshot(chatHistoryDocRef(), (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const data = docSnapshot.data();
                    const messages = data.messages || [];
                    
                    if (JSON.stringify(messages) !== JSON.stringify(chatHistory)) {
                        chatHistory = messages;
                        renderChatHistory();
                    }
                } else {
                    saveChatHistory();
                }
            }, (error) => {
                console.error("Error listening to chat history: ", error);
                chatWindow.innerHTML = '<div class="text-center text-sm text-red-500">Error loading chat history.</div>';
            });
        }

        async function saveChatHistory() {
            if (!isAuthReady || !chatHistoryDocRef()) return;

            try {
                await setDoc(chatHistoryDocRef(), { messages: chatHistory }, { merge: true });
            } catch (error) {
                console.error("Error saving chat history: ", error);
            }
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                userId = user.uid;
                userIdDisplay.textContent = `User ID: ${userId}`;
                isAuthReady = true;
                
                loadProgress();
                loadChatHistory();
                
            } else {
                isAuthReady = false;
                userId = null; 
                userIdDisplay.textContent = "User ID: Not Authenticated";
                phraseEnElement.textContent = currentPhrases[0].en; // Show first phrase as fallback
            }
        });

        initializeAuth();


        // --- Tutor Mode Logic ---

        function updateMasteryIndicator(masteryCount, isDynamic = false) {
             if (isDynamic) {
                 masteryIndicator.textContent = `Dynamic Phrase (Topic: ${currentPhrase.topic})`;
                 masteryIndicator.classList.add('text-blue-500');
                 masteryIndicator.classList.remove('text-amber-500', 'text-green-500');
                 return;
             }
             const stars = Array(Math.min(masteryCount, masteredThreshold)).fill('â­').join('');
             masteryIndicator.textContent = `Phrase Mastery: ${stars} (${Math.min(masteryCount, masteredThreshold)}/${masteredThreshold})`;
             masteryIndicator.classList.remove('text-amber-500', 'text-green-500', 'text-blue-500');
             if (masteryCount >= masteredThreshold) {
                 masteryIndicator.classList.add('text-green-500');
             } else if (masteryCount > 0) {
                 masteryIndicator.classList.add('text-amber-500');
             }
        }

        async function generateDynamicPhrase() {
            isGeneratingPhrase = true;
            tutorSystemMessageElement.textContent = "Generating a new, advanced phrase with AI...";
            tutorSystemMessageElement.classList.add('opacity-100', 'text-blue-500');
            
            phraseEnElement.textContent = '<i class="fas fa-spinner fa-spin"></i>';
            phraseItElement.textContent = '';
            answerInput.value = '';
            
            // Disable buttons during generation
            checkBtn.disabled = true;
            revealBtn.disabled = true;
            tutorListenBtn.disabled = true;
            phrasePromptElement.textContent = "";

            const languageName = languageSelect.value === 'italian' ? 'Italian' : 'Sicilian';
            const userQuery = `Generate a useful intermediate/advanced phrase in English and its accurate, idiomatic translation into ${languageName}. Also provide a short topic.`;
            
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "englishPhrase": { "type": "STRING" },
                            "translation": { "type": "STRING" },
                            "topic": { "type": "STRING" }
                        },
                        "propertyOrdering": ["englishPhrase", "translation", "topic"]
                    }
                }
            };

            let generatedData = null;
            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const response = await fetch(GEMINI_TEXT_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    // Handle exponential backoff
                    if (response.status === 429 && attempt < 2) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    if (!response.ok) throw new Error(`API returned status ${response.status}`);

                    const result = await response.json();
                    const jsonString = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                    generatedData = JSON.parse(jsonString);
                    break;
                } catch (error) {
                    console.error("Dynamic Phrase Generation Error:", error);
                }
            }

            checkBtn.disabled = false;
            revealBtn.disabled = false;
            tutorListenBtn.disabled = false;
            isGeneratingPhrase = false;
            tutorSystemMessageElement.classList.remove('opacity-100');

            if (generatedData && generatedData.englishPhrase && generatedData.translation) {
                currentPhrase = {
                    en: generatedData.englishPhrase,
                    it: generatedData.translation,
                    topic: generatedData.topic || 'General' 
                };
                
                phraseEnElement.textContent = currentPhrase.en;
                phraseItElement.textContent = currentPhrase.it;
                updateMasteryIndicator(0, true); 
                
                // Dynamic phrases are always English -> Target Language for simplicity
                phraseEnElement.classList.remove('hidden');
                phraseItElement.classList.add('hidden');
                phrasePromptElement.textContent = "Translate to " + (languageSelect.value === 'italian' ? 'Italian' : 'Sicilian');
                answerInput.placeholder = "Type the translation...";
            } else {
                currentPhrase = { en: "Error generating phrase.", it: "Errore.", topic: "Error" };
                phraseEnElement.textContent = "Could not generate phrase. Try again or check the API key.";
                phraseItElement.textContent = currentPhrase.it;
                updateMasteryIndicator(0, true); 
                tutorSystemMessageElement.textContent = "AI Generation failed.";
                tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
            }
        }


        function loadNextPhrase() {
            if (!isAuthReady && !userId) {
                phraseEnElement.textContent = "Authenticating...";
                return;
            }
            
            // Find the least mastered static phrase (simple spaced repetition)
            const availablePhrases = currentPhrases.filter(p => p.mastered < masteredThreshold);
            
            if (availablePhrases.length === 0) {
                // All static phrases mastered, switch to AI generation
                generateDynamicPhrase();
                isReverseChallenge = false;
                return;
            }

            // Simple randomization among the least mastered group
            availablePhrases.sort((a, b) => a.mastered - b.mastery);
            const lowestMastery = availablePhrases.length > 0 ? availablePhrases[0].mastered : 0;
            const pool = availablePhrases.filter(p => p.mastered === lowestMastery);

            currentPhrase = pool[Math.floor(Math.random() * pool.length)] || currentPhrases[0];
            
            // CHALLENGE LOGIC: Switch to reverse translation at mastery level 3
            isReverseChallenge = currentPhrase.mastered >= 3 && currentPhrase.mastered < masteredThreshold;
            
            const targetLangName = languageSelect.value === 'italian' ? 'Italian' : 'Sicilian';

            if (isReverseChallenge) {
                phraseEnElement.classList.add('hidden');
                phraseItElement.classList.remove('hidden');
                phrasePromptElement.textContent = "Translate to English (Challenge Mode)";
                answerInput.placeholder = "Type the English translation...";
            } else {
                phraseEnElement.classList.remove('hidden');
                phraseItElement.classList.add('hidden');
                phrasePromptElement.textContent = `Translate to ${targetLangName}`;
                answerInput.placeholder = `Type the ${targetLangName} translation...`;
            }

            // Set content
            phraseEnElement.textContent = currentPhrase.en;
            phraseItElement.textContent = currentPhrase.it;

            updateMasteryIndicator(currentPhrase.mastered); 

            // Reset UI
            answerInput.value = '';
            answerInput.classList.remove('correct-answer-input', 'border-red-500');
            checkBtn.classList.remove('hidden');
            revealBtn.classList.remove('hidden');
            nextBtn.classList.add('hidden');
            tutorFeedbackElement.textContent = '';
            tutorSystemMessageElement.classList.remove('opacity-100');
        }

        function cleanString(str) {
             // Remove all punctuation, convert to lowercase, and trim whitespace
            return str.trim().toLowerCase().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ' ');
        }

        function checkAnswer() {
            if (isGeneratingPhrase) return;

            const userAnswerClean = cleanString(answerInput.value);
            let correctAnswerClean;
            let expectedAnswer;

            if (isReverseChallenge) {
                // Reverse Challenge: Check user input (English) against correct English phrase (currentPhrase.en)
                correctAnswerClean = cleanString(currentPhrase.en);
                expectedAnswer = currentPhrase.en;
            } else {
                // Standard Challenge: Check user input (Target) against correct Target phrase (currentPhrase.it)
                correctAnswerClean = cleanString(currentPhrase.it);
                expectedAnswer = currentPhrase.it;
            }

            if (userAnswerClean === correctAnswerClean) {
                tutorFeedbackElement.textContent = 'Correct! Molto bene!';
                tutorFeedbackElement.classList.add('text-green-500');
                tutorFeedbackElement.classList.remove('text-red-500', 'text-blue-500');
                
                answerInput.classList.add('correct-answer-input');
                answerInput.classList.remove('border-red-500');
                
                // Only update and save progress for STATIC phrases
                if (currentPhrase.mastered !== undefined && currentPhrase.mastered < masteredThreshold) {
                    currentPhrase.mastered = (currentPhrase.mastered || 0) + 1;
                    saveProgress();
                    calculateOverallProgress(); // Recalculate overall progress
                }
                
                updateMasteryIndicator(currentPhrase.mastered);
                
                checkBtn.classList.add('hidden');
                revealBtn.classList.add('hidden');
                nextBtn.classList.remove('hidden');
            } else {
                tutorFeedbackElement.textContent = 'Incorrect. Try again!';
                tutorFeedbackElement.classList.add('text-red-500');
                tutorFeedbackElement.classList.remove('text-green-500', 'text-blue-500');
                answerInput.classList.add('border-red-500');
                answerInput.classList.remove('correct-answer-input');
            }
        }

        function revealAnswer() {
            let correctAnswer = isReverseChallenge ? currentPhrase.en : currentPhrase.it;

            phraseEnElement.classList.add('hidden');
            phraseItElement.classList.remove('hidden');
            checkBtn.classList.add('hidden');
            revealBtn.classList.add('hidden');
            nextBtn.classList.remove('hidden');
            tutorFeedbackElement.textContent = `The correct answer is: ${correctAnswer}`;
            tutorFeedbackElement.classList.add('text-blue-500');
            tutorFeedbackElement.classList.remove('text-red-500', 'text-green-500');
        }
        
        // --- TTS Utility functions (Base64 to ArrayBuffer and AudioContext) ---

        let audioContext = null;

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function ttsToAudio(audioData, mimeType) {
            if (!audioData || !mimeType) {
                console.error("Missing audio data or mime type.");
                return;
            }

            if (!audioContext) {
                // Initialize AudioContext on user interaction
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (audioContext.state === 'suspended') {
                // Attempt to resume the context if it's suspended
                audioContext.resume().catch(e => console.error("Error resuming AudioContext:", e));
            }

            const match = mimeType.match(/rate=(\d+)/);
            const sampleRate = match ? parseInt(match[1], 10) : 24000; 

            try {
                const pcmDataBuffer = base64ToArrayBuffer(audioData);
                const numChannels = 1;
                
                // The API returns signed 16-bit PCM data (Int16Array)
                const pcm16 = new Int16Array(pcmDataBuffer);
                
                const audioBuffer = audioContext.createBuffer(numChannels, pcm16.length, sampleRate);
                const channelData = audioBuffer.getChannelData(0);

                // Convert signed 16-bit integer to floating point (-1.0 to 1.0)
                for (let i = 0; i < pcm16.length; i++) {
                    channelData[i] = pcm16[i] / 32768.0; 
                }

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start(0);

            } catch (error) {
                console.error("Error processing PCM data with AudioContext:", error);
                tutorSystemMessageElement.textContent = "Error playing audio with AudioContext. Check Console!";
                tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
                setTimeout(() => tutorSystemMessageElement.classList.remove('opacity-100'), 3000);
            }
        }


        // TTS Function for Tutor Mode
        async function fetchTutorTTS(text) {
            tutorListenBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            tutorListenBtn.disabled = true;

            const language = languageSelect.value;
            const voiceName = language === 'italian' ? 'Kore' : 'Charon'; 
            
            if (!API_KEY && typeof __app_id === 'undefined') { 
                 tutorSystemMessageElement.textContent = "AI Key Missing. Cannot play audio.";
                 tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
                 setTimeout(() => tutorSystemMessageElement.classList.remove('opacity-100'), 3000);
                 tutorListenBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
                 tutorListenBtn.disabled = false;
                 return;
            }

            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: text }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetch(GEMINI_TTS_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && attempt < 2) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }

                    if (!response.ok) throw new Error(`API returned status ${response.status}`);

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType) {
                        ttsToAudio(audioData, mimeType);
                    } else {
                        throw new Error("TTS response missing audio data.");
                    }
                    
                    break; 
                } catch (error) {
                    console.error("TTS Fetch Error:", error);
                    if (attempt === 2) {
                        tutorSystemMessageElement.textContent = "Error playing audio.";
                        tutorSystemMessageElement.classList.add('opacity-100', 'text-red-500');
                    }
                }
            }

            tutorListenBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
            tutorListenBtn.disabled = false;
        }


        // Event Listeners for Tutor Mode
        checkBtn.addEventListener('click', checkAnswer);
        nextBtn.addEventListener('click', loadNextPhrase);
        revealBtn.addEventListener('click', revealAnswer);
        tutorListenBtn.addEventListener('click', () => {
            if (!currentPhrase) return;
            // Only speak the target language phrase
            const textToSpeak = currentPhrase.it;
            fetchTutorTTS(textToSpeak);
        });
        
        tutorSpeakBtn.addEventListener('click', () => {
             tutorSystemMessageElement.textContent = "Speech input is not available in this environment. Please type your answer.";
             tutorSystemMessageElement.classList.add('opacity-100', 'text-orange-500');
             setTimeout(() => tutorSystemMessageElement.classList.remove('opacity-100'), 3000);
        });

        // --- Chat Mode Logic ---

        function renderChatMessage(role, text) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('max-w-[80%]', 'p-3', 'rounded-xl', 'shadow-sm', 'break-words');

            if (role === 'user') {
                messageDiv.classList.add('chat-message-user');
            } else if (role === 'model') {
                messageDiv.classList.add('chat-message-ai');
            } else if (role === 'system') {
                messageDiv.classList.add('text-center', 'text-xs', 'text-gray-500', 'dark:text-gray-400', 'w-full');
            }

            messageDiv.textContent = text;
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function renderChatHistory() {
            chatWindow.innerHTML = '';
            if (chatHistory.length === 0) {
                 chatWindow.innerHTML = '<div class="text-center text-sm text-gray-500 dark:text-gray-400">Start a conversation with the AI tutor.</div>';
                 return;
            }
            chatHistory.forEach(message => {
                renderChatMessage(message.role, message.parts[0].text);
            });
        }
        
        async function sendChat() {
            if (isWaitingForResponse) return;
            const userQuery = chatInput.value.trim();
            if (!userQuery) return;

            if (!API_KEY && typeof __app_id === 'undefined') {
                renderChatMessage('system', "AI Chat Failed: Missing Google Gemini API Key.");
                return;
            }

            chatInput.value = '';
            
            const userMessage = { role: "user", parts: [{ text: userQuery }] };
            chatHistory.push(userMessage);
            renderChatMessage('user', userQuery);
            
            isWaitingForResponse = true;
            chatSendBtn.disabled = true;
            chatSendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            
            const language = languageSelect.value;
            const systemPrompt = `You are a helpful, enthusiastic, and patient language tutor specializing in ${language}. Keep your responses friendly, encouraging, and concise. Only respond in English, but use and teach ${language} phrases relevant to the user's question.`;

            const payload = {
                contents: chatHistory,
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };
            
            let modelResponseText = "Sorry, I couldn't get a response from the tutor. This usually means the Gemini API Key is missing or invalid.";
            
            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const response = await fetch(GEMINI_TEXT_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && attempt < 2) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }
                    
                    if (!response.ok) throw new Error(`API returned status ${response.status}`);

                    const result = await response.json();
                    const candidate = result.candidates?.[0];
                    modelResponseText = candidate?.content?.parts?.[0]?.text || modelResponseText;
                    
                    break; 
                } catch (error) {
                    console.error("Gemini Chat Fetch Error:", error);
                }
            }

            const modelMessage = { role: "model", parts: [{ text: modelResponseText }] };
            chatHistory.push(modelMessage);
            renderChatMessage('model', modelResponseText);
            
            saveChatHistory();

            isWaitingForResponse = false;
            chatSendBtn.disabled = false;
            chatSendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
        }

        chatSendBtn.addEventListener('click', sendChat);
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                sendChat();
            }
        });
        
        chatSpeakBtn.addEventListener('click', () => {
            if (isWaitingForResponse || chatHistory.length === 0) return;
            
            const lastModelMessage = [...chatHistory].reverse().find(m => m.role === 'model');
            if (lastModelMessage) {
                const textToSpeak = lastModelMessage.parts[0].text;
                const voiceName = languageSelect.value === 'italian' ? 'Leda' : 'Umbriel';

                fetchChatTTS(textToSpeak, voiceName);
            }
        });

        async function fetchChatTTS(text, voiceName) {
            chatSpeakBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            chatSpeakBtn.disabled = true;
            
            if (!API_KEY && typeof __app_id === 'undefined') { 
                 renderChatMessage('system', "AI TTS Failed: Missing Google Gemini API Key.");
                 chatSpeakBtn.innerHTML = '<i class="fas fa-microphone"></i>';
                 chatSpeakBtn.disabled = false;
                 return;
            }

            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: `Say in a friendly, encouraging tone: ${text}` }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetch(GEMINI_TTS_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && attempt < 2) {
                        const delay = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }

                    if (!response.ok) throw new Error(`API returned status ${response.status}`);

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType) {
                        ttsToAudio(audioData, mimeType); 
                    } else {
                        throw new Error("TTS response missing audio data.");
                    }
                    
                    break; 
                } catch (error) {
                    console.error("Chat TTS Fetch Error:", error);
                }
            }
            
            chatSpeakBtn.innerHTML = '<i class="fas fa-microphone"></i>';
            chatSpeakBtn.disabled = false;
        }

        // --- Initial Load ---
        window.onload = () => {
            const initialLanguage = languageSelect.value;
            currentPhrases = initialLanguage === 'italian' ? italianPhrases : sicilianPhrases;
            phraseEnElement.textContent = "Loading...";
            updateFlagDisplay(initialLanguage); 
            calculateOverallProgress(); // Set initial progress to 0
        };

    </script>
</body>
</html>