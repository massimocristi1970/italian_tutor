<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Italian & Sicilian Tutor</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .pulse-animation {
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.5;
            }
        }
        .word-button {
            cursor: pointer;
            @apply bg-white border border-gray-300 text-gray-800 rounded-lg px-4 py-2 text-sm font-medium transition-all duration-150 hover:bg-blue-500 hover:text-white dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500 dark:hover:bg-blue-600;
        }
        .word-button.in-sentence {
            cursor: pointer;
            @apply bg-blue-500 text-white shadow-md;
        }
    </style>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="flex items-center justify-center min-h-screen p-4 transition-colors duration-500 bg-gray-100 dark:bg-gray-900">
    <!-- Main application container -->
    <div class="bg-white p-6 sm:p-8 rounded-xl shadow-lg w-full max-w-sm sm:max-w-lg transition-colors duration-500 dark:bg-gray-800">
        <!-- Header with language selection and user ID -->
        <div class="flex items-center justify-between mb-6 flex-wrap">
            <h1 class="text-xl sm:text-2xl font-bold text-gray-800 text-center flex-grow dark:text-gray-100">Dynamic Language Tutor</h1>
            <div class="flex items-center space-x-2">
                <span id="flag-display" class="text-3xl">ðŸ‡®ðŸ‡¹</span>
                <select id="language-select" class="bg-gray-200 text-gray-800 p-2 rounded-lg cursor-pointer dark:bg-gray-700 dark:text-gray-100 mt-2 sm:mt-0">
                    <option value="italian">Italian</option>
                    <option value="sicilian">Sicilian</option>
                </select>
            </div>
            <div id="user-id-display" class="w-full text-center text-xs text-gray-600 mt-2 truncate dark:text-gray-400">User ID: Loading...</div>
        </div>
        
        <!-- Mode Toggle Buttons -->
        <div class="flex justify-center space-x-4 mb-6">
            <button id="tutor-mode-btn" class="py-2 px-4 rounded-lg font-semibold bg-blue-500 text-white transition-colors duration-300">Phrase Tutor</button>
            <button id="chat-mode-btn" class="py-2 px-4 rounded-lg font-semibold bg-gray-200 text-gray-800 transition-colors duration-300 dark:bg-gray-700 dark:text-gray-100">AI Chat</button>
        </div>

        <!-- Progress Bar -->
        <div id="progress-container" class="mb-6">
            <div class="flex justify-between text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                <span>Total Mastered Phrases</span>
                <span id="progress-percent">0/0 Mastered</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-500" style="width: 0%"></div>
            </div>
            <p id="level-indicator" class="text-xs text-center text-gray-500 mt-2 dark:text-gray-400">Current Level: Beginner</p>
        </div>

        <!-- Tutor Section (Sentence Builder) -->
        <div id="tutor-section" class="text-center">
            <!-- System message/alert container -->
            <div id="tutor-system-message" class="text-center font-semibold text-sm mb-4 h-6 opacity-0 transition-opacity duration-500 text-gray-800 dark:text-gray-100"></div>

            <!-- Flashcard content (English Phrase) -->
            <div class="h-20 sm:h-24 flex items-center justify-center bg-gray-50 rounded-lg p-4 mb-6 transition-colors duration-500 dark:bg-gray-700">
                <div class="flex flex-col">
                    <p id="phrase-en" class="text-lg sm:text-2xl font-medium text-gray-800 transition-opacity duration-300 dark:text-gray-100">Loading phrase...</p>
                    <!-- Mastery Indicator -->
                    <div id="mastery-indicator" class="text-xs mt-1 font-semibold text-gray-500 dark:text-gray-400"></div>
                </div>
            </div>

            <!-- Sentence Construction Area -->
            <div class="text-left text-sm font-semibold text-gray-700 mb-2 dark:text-gray-300">Your Sentence:</div>
            <div id="current-sentence" class="min-h-[50px] p-3 border-2 border-dashed border-gray-400 rounded-lg mb-4 flex flex-wrap gap-2 items-center dark:bg-gray-700 dark:border-gray-500">
                <!-- Selected word buttons will appear here -->
            </div>

            <!-- Word Bank -->
            <div class="text-left text-sm font-semibold text-gray-700 mb-2 dark:text-gray-300">Word Bank:</div>
            <div id="word-bank" class="min-h-[80px] p-3 bg-gray-100 rounded-lg flex flex-wrap gap-2 justify-center mb-6 transition-colors duration-500 dark:bg-gray-700">
                <!-- Shuffled word buttons and distractors will appear here -->
            </div>

            <!-- Feedback and action buttons -->
            <div id="tutor-feedback" class="text-center text-sm font-semibold h-6 mb-4"></div>
            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
                <button id="check-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg w-full transition-all duration-300 transform hover:scale-105 shadow-md">
                    Check Sentence
                </button>
                <button id="next-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-3 px-6 rounded-lg w-full transition-all duration-300 transform hover:scale-105 shadow-md hidden">
                    Next Phrase
                </button>
                <button id="reveal-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg w-full transition-all duration-300 transform hover:scale-105 shadow-md">
                    Reveal Answer
                </button>
            </div>
             <!-- Listen Button -->
            <div class="mt-4">
                <button id="tutor-listen-btn" class="bg-gray-200 text-gray-800 p-3 rounded-lg transition-all duration-300 hover:bg-gray-300 w-full dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600">
                    <i class="fas fa-volume-up mr-2"></i> Listen to the correct phrase
                </button>
            </div>
        </div>

        <!-- Chat Section -->
        <div id="chat-section" class="hidden flex flex-col h-[60vh] max-h-[600px] overflow-hidden">
            <div id="chat-window" class="flex-grow p-4 bg-gray-50 rounded-lg mb-4 overflow-y-auto transition-colors duration-500 dark:bg-gray-700">
                <div class="text-center text-sm text-gray-500 dark:text-gray-400">Start a conversation with the AI tutor.</div>
            </div>
            <div class="flex items-center space-x-2">
                <input id="chat-input" type="text" placeholder="Send a message..."
                       class="flex-grow p-3 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500 transition-all duration-300 dark:bg-gray-900 dark:border-gray-600 dark:text-gray-100">
                <button id="chat-send-btn" class="bg-blue-500 hover:bg-blue-600 text-white p-3 rounded-lg transition-all duration-300">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Ensure Firebase logging is enabled for debugging
        setLogLevel('debug');

        // --- Global Environment Setup (Constants must be present) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- Ambiente Firebase Configuration (FIX CRITICO) ---
        // FIX: Sostituzione della configurazione segnaposto con la variabile globale.
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        
        // --- Core Application State & Firebase References ---
        let db = null; // Set to null initially
        let auth = null; // Set to null initially
        let userId = null;
        let chatHistory = [];
        let isWaitingForResponse = false;
        
        // -----------------------------------------------------------
        // --- IMPORTANT: PASTE YOUR GEMINI API KEY HERE ---
        // -----------------------------------------------------------
        const API_KEY = "AIzaSyBJzBPjcCDlDaN0G2OyBrm6zwr7oLI1aUU"; // Key is provided by the environment if left empty
        const GEMINI_TEXT_API = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=" + API_KEY;
        const GEMINI_TTS_API = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=" + API_KEY;
        
        // --- Phrase Data (Mastery system preserved) ---
        const masteredThreshold = 2; // Need 2 correct answers to master a phrase
        
        // IMPORTANT: We use these as a base, and the live 'currentPhrases' array will grow
        // as the user generates dynamic content.
        const baseItalianPhrases = [
            { en: "Hello", it: "Ciao", mastered: 0, static: true },
            { en: "Thank you very much", it: "Grazie mille", mastered: 0, static: true },
            { en: "Please, a bottle of water", it: "Per favore, una bottiglia d'acqua", mastered: 0, static: true },
            { en: "Excuse me, where is the station?", it: "Mi scusi, dov'Ã¨ la stazione?", mastered: 0, static: true },
            { en: "Yes, I like the red wine", it: "SÃ¬, mi piace il vino rosso", mastered: 0, static: true },
            { en: "No, I do not want the fish", it: "No, non voglio il pesce", mastered: 0, static: true },
            { en: "Goodbye, see you tomorrow", it: "Arrivederci, a domani", mastered: 0, static: true },
            { en: "How are you doing today?", it: "Come stai oggi?", mastered: 0, static: true },
            { en: "I don't understand the question", it: "Non capisco la domanda", mastered: 0, static: true },
            { en: "Do you speak English or French?", it: "Parli inglese o francese?", mastered: 0, static: true },
            { en: "What is your name, sir?", it: "Qual Ã¨ il tuo nome, signore?", mastered: 0, static: true },
            { en: "My name is Antonio", it: "Mi chiamo Antonio", mastered: 0, static: true },
            { en: "Where are you from, madam?", it: "Di dove sei, signora?", mastered: 0, static: true },
            { en: "I am from Rome, in Italy", it: "Sono di Roma, in Italia", mastered: 0, static: true },
            { en: "I am sorry for the delay", it: "Mi dispiace per il ritardo", mastered: 0, static: true },
            { en: "How much does this coffee cost?", it: "Quanto costa questo caffÃ¨?", mastered: 0, static: true },
            { en: "The food is delicious and hot", it: "Il cibo Ã¨ delizioso e caldo", mastered: 0, static: true },
            { en: "I would like a large cappuccino", it: "Vorrei un cappuccino grande", mastered: 0, static: true },
            { en: "I am tired after the long trip", it: "Sono stanco dopo il lungo viaggio", mastered: 0, static: true },
            { en: "Let's go to the market now", it: "Andiamo al mercato ora", mastered: 0, static: true }
        ];

        const baseSicilianPhrases = [
            { en: "Hello", it: "Salutu", mastered: 0, static: true },
            { en: "Thank you very much", it: "GrazzÃ® assai", mastered: 0, static: true },
            { en: "Please, a bottle of water", it: "Pi favuri, na buttÃ¬gghia d'acqua", mastered: 0, static: true },
            { en: "Excuse me, where is the station?", it: "M'accatti, unni Ã¨ la stazzioni?", mastered: 0, static: true },
            { en: "Yes, I like the red wine", it: "SÃ¬, mi piaci lu vinu russu", mastered: 0, static: true },
            { en: "No, I do not want the fish", it: "No, nun vogghiu lu pisci", mastered: 0, static: true },
            { en: "Goodbye, see you tomorrow", it: "Addiu, nni videmu dumani", mastered: 0, static: true },
            { en: "How are you doing today?", it: "Comu si senti Ã²i?", mastered: 0, static: true },
            { en: "I don't understand the question", it: "Nun capisciu la dumannata", mastered: 0, static: true },
            { en: "Do you speak English or French?", it: "Parra ngrisi o francisi?", mastered: 0, static: true },
            { en: "What is your name, sir?", it: "Qual Ã¨ lu tÃ² nomi, signuri?", mastered: 0, static: true },
            { en: "My name is Antonio", it: "Mi chiÃ mu Antoniu", mastered: 0, static: true },
            { en: "Where are you from, madam?", it: "Di unni si, signura?", mastered: 0, static: true },
            { en: "I am from Rome, in Italy", it: "Sugnu di Roma, 'n Talia", mastered: 0, static: true },
            { en: "I am sorry for the delay", it: "M'addulÃ¬u pÃ» ritardu", mastered: 0, static: true },
            { en: "How much does this coffee cost?", it: "Quantu costa stu cafÃ¨?", mastered: 0, static: true },
            { en: "The food is delicious and hot", it: "Lu manciari Ã¨ diliziusu e cÃ udu", mastered: 0, static: true },
            { en: "I would like a large cappuccino", it: "VuÃ²gghiu un cappuccinu granni", mastered: 0, static: true },
            { en: "I am tired after the long trip", it: "Sugnu stancu doppu lu longu viÃ ggiu", mastered: 0, static: true },
            { en: "Let's go to the market now", it: "Iemu Ã´ mircatu ora", mastered: 0, static: true }
        ];

        let currentPhrases = []; // This will hold all phrases, static and dynamic
        let currentPhrase = null;
        let isGeneratingPhrase = false;


        // --- DOM Element References ---
        const languageSelect = document.getElementById('language-select');
        const tutorSection = document.getElementById('tutor-section');
        const chatSection = document.getElementById('chat-section');
        const tutorModeBtn = document.getElementById('tutor-mode-btn');
        const chatModeBtn = document.getElementById('chat-mode-btn');
        const flagDisplay = document.getElementById('flag-display');
        const phraseEnElement = document.getElementById('phrase-en');
        const masteryIndicator = document.getElementById('mastery-indicator');
        const currentSentenceElement = document.getElementById('current-sentence');
        const wordBankElement = document.getElementById('word-bank');
        const tutorListenBtn = document.getElementById('tutor-listen-btn');
        const checkBtn = document.getElementById('check-btn');
        const nextBtn = document.getElementById('next-btn');
        const revealBtn = document.getElementById('reveal-btn');
        const tutorFeedbackElement = document.getElementById('tutor-feedback');
        const tutorSystemMessageElement = document.getElementById('tutor-system-message');
        const userIdDisplay = document.getElementById('user-id-display');
        const chatWindow = document.getElementById('chat-window');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const progressBarElement = document.getElementById('progress-bar');
        const progressPercentElement = document.getElementById('progress-percent');
        const levelIndicator = document.getElementById('level-indicator');

        // --- Firebase Data Reference Helpers ---
        // Only return a valid reference if the database is initialized
        const progressDocRef = () => db && userId ? doc(db, 'artifacts', appId, 'users', userId, 'progress', languageSelect.value) : null;
        const chatHistoryDocRef = () => db && userId ? doc(db, 'artifacts', appId, 'users', userId, 'chat', languageSelect.value) : null;

        // --- Utility Functions for TTS (PCM to WAV conversion) ---

        /** Converts base64 to ArrayBuffer */
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /** Creates a WAV Blob from raw PCM data */
        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataLength = pcm16.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            let offset = 0;

            // RIFF chunk
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + dataLength, true); offset += 4;
            writeString(view, offset, 'WAVE'); offset += 4;

            // FMT chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4; // Sub-chunk size: 16
            view.setUint16(offset, 1, true); offset += 2; // Audio format (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, byteRate, true); offset += 4;
            view.setUint16(offset, blockAlign, true); offset += 2;
            view.setUint16(offset, 16, true); offset += 2; // Bits per sample

            // DATA chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, dataLength, true); offset += 4;

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++, offset += 2) {
                view.setInt16(offset, pcm16[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        async function speakText(text) {
            const audioBtn = document.getElementById('tutor-listen-btn');
            audioBtn.disabled = true;
            const originalText = audioBtn.innerHTML;
            audioBtn.innerHTML = `<i class="fas fa-volume-up pulse-animation mr-2"></i> Generating Audio...`;

            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            // Using a friendly, clear voice
                            prebuiltVoiceConfig: { voiceName: "Achird" } 
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            try {
                const response = await fetch(GEMINI_TTS_API, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) throw new Error(`TTS API HTTP error! status: ${response.status}`);
                
                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    if (!sampleRateMatch) throw new Error("Could not determine sample rate from MIME type.");

                    const sampleRate = parseInt(sampleRateMatch[1], 10);
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    
                    const audio = new Audio(URL.createObjectURL(wavBlob));
                    audio.play();
                } else {
                    console.error("TTS response missing audio data.");
                    showTutorSystemMessage("TTS failed: Audio data missing.");
                }

            } catch (error) {
                console.error('Error with Gemini TTS:', error);
                showTutorSystemMessage(`TTS failed: ${error.message}`);
            } finally {
                audioBtn.innerHTML = originalText;
                audioBtn.disabled = false;
            }
        }


        // --- UI & Utility Functions ---
        function switchMode(mode) {
            if (mode === 'tutor') {
                tutorSection.classList.remove('hidden', 'flex');
                chatSection.classList.add('hidden');
                tutorModeBtn.classList.add('bg-blue-500', 'text-white');
                tutorModeBtn.classList.remove('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                chatModeBtn.classList.remove('bg-blue-500', 'text-white');
                chatModeBtn.classList.add('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
            } else {
                chatSection.classList.remove('hidden');
                chatSection.classList.add('flex');
                tutorSection.classList.add('hidden');
                chatModeBtn.classList.add('bg-blue-500', 'text-white');
                chatModeBtn.classList.remove('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                tutorModeBtn.classList.remove('bg-blue-500', 'text-white');
                tutorModeBtn.classList.add('bg-gray-200', 'text-gray-800', 'dark:bg-gray-700', 'dark:text-gray-100');
                loadChatHistory();
            }
        }

        function updateFlag() {
            flagDisplay.textContent = languageSelect.value === 'italian' ? 'ðŸ‡®ðŸ‡¹' : 'ðŸ‡¸ðŸ‡®'; // Using Sicily flag
        }

        function showTutorSystemMessage(message) {
            tutorSystemMessageElement.textContent = message;
            tutorSystemMessageElement.classList.remove('opacity-0');
            tutorSystemMessageElement.classList.add('opacity-100');
            setTimeout(() => {
                tutorSystemMessageElement.classList.remove('opacity-100');
                tutorSystemMessageElement.classList.add('opacity-0');
            }, 3000);
        }
        
        function appendChatMessage(message, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('my-2', 'p-3', 'rounded-lg', 'max-w-[80%]');
            if (sender === 'user') {
                messageDiv.classList.add('bg-blue-500', 'text-white', 'ml-auto');
            } else {
                messageDiv.classList.add('bg-gray-200', 'text-gray-800', 'dark:bg-gray-600', 'dark:text-gray-100');
            }
            messageDiv.textContent = message;
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }
        
        function renderMastery() {
            if (!currentPhrase) return;
            const masteredCount = currentPhrase.mastered;
            const target = masteredThreshold;
            
            if (masteredCount >= target) {
                masteryIndicator.innerHTML = `<i class="fas fa-check-circle text-green-500"></i> Mastered!`;
            } else if (masteredCount >= 0) {
                masteryIndicator.innerHTML = `Mastery: <span class="text-blue-500 font-bold">${masteredCount}/${target}</span>`;
            } else {
                masteryIndicator.innerHTML = `<i class="fas fa-times-circle text-red-500"></i> Needs practice`;
            }
        }

        function updateProgressBar() {
            const totalPhrases = currentPhrases.length;
            if (totalPhrases === 0) {
                progressPercentElement.textContent = `0/0 Mastered`;
                progressBarElement.style.width = '0%';
                levelIndicator.textContent = 'Current Level: Beginner';
                return;
            }

            const masteredCount = currentPhrases.filter(p => p.mastered >= masteredThreshold).length;
            const totalToMaster = currentPhrases.length;
            
            // Percentage based on static phrases for initial level determination
            const staticMastered = currentPhrases.filter(p => p.static && p.mastered >= masteredThreshold).length;
            const staticTotal = baseItalianPhrases.length; // Use Italian base length (20)
            const staticPercent = Math.round((staticMastered / staticTotal) * 100);


            // Determine Level based on static phrase mastery
            let levelText = 'Beginner';
            if (staticPercent >= 50 && staticPercent < 80) {
                levelText = 'Intermediate';
            } else if (staticPercent >= 80) {
                levelText = 'Advanced';
            }

            progressPercentElement.textContent = `${masteredCount}/${totalToMaster} Mastered`;
            
            // Visual bar based on overall count
            const overallProgress = Math.min(100, Math.round((masteredCount / totalToMaster) * 100));
            progressBarElement.style.width = `${overallProgress}%`;

            levelIndicator.textContent = `Current Level: ${levelText}`;

            if (masteredCount >= totalToMaster) {
                progressBarElement.classList.remove('bg-blue-600');
                progressBarElement.classList.add('bg-green-500');
            } else {
                progressBarElement.classList.remove('bg-green-500');
                progressBarElement.classList.add('bg-blue-600');
            }
        }

        // --- Sentence Builder Logic ---
        function renderWordBank(words) {
            wordBankElement.innerHTML = '';
            currentSentenceElement.innerHTML = '';

            words.forEach(word => {
                const button = createWordButton(word, 'bank');
                wordBankElement.appendChild(button);
            });
            wordBankElement.classList.remove('opacity-0');
        }

        function createWordButton(word, location) {
            const button = document.createElement('button');
            button.textContent = word;
            button.classList.add('word-button');
            button.setAttribute('data-word', word);
            button.setAttribute('data-location', location);
            
            if (location === 'sentence') {
                button.classList.add('in-sentence');
            }

            button.addEventListener('click', () => {
                const currentLoc = button.getAttribute('data-location');
                if (currentLoc === 'bank') {
                    // Move from bank to sentence
                    button.classList.add('in-sentence');
                    currentSentenceElement.appendChild(button);
                    button.setAttribute('data-location', 'sentence');
                    tutorFeedbackElement.textContent = ''; // Clear feedback on move
                } else {
                    // Move from sentence back to bank
                    button.classList.remove('in-sentence');
                    wordBankElement.appendChild(button);
                    button.setAttribute('data-location', 'bank');
                }
                checkButtonState();
            });
            return button;
        }

        function checkButtonState() {
            // Only enable check/reveal if there are words in the sentence
            const hasWords = currentSentenceElement.children.length > 0;
            checkBtn.disabled = !hasWords || isGeneratingPhrase;
            revealBtn.disabled = !hasWords || isGeneratingPhrase;
        }

        /**
         * Calls Gemini API to generate a new phrase and adds it to currentPhrases.
         */
        async function generateDynamicPhrase(targetLanguage, level) {
            isGeneratingPhrase = true;
            phraseEnElement.textContent = "Generating new challenge...";
            wordBankElement.innerHTML = `<i class="fas fa-spinner fa-spin text-xl text-blue-500"></i> Generating...`;
            checkButtonState();

            const targetLangFull = targetLanguage === 'italian' ? 'Modern Italian' : 'Sicilian dialect';
            
            const prompt = `Generate a new, unique phrase in ${targetLangFull} and its English translation. The phrase should be challenging for a ${level} learner. The output MUST be a strict JSON object with two fields: "en" for the English phrase and "it" for the ${targetLangFull} phrase. Do NOT include any markdown, backticks, or other text outside the JSON object. Example: {"en": "I will buy a ticket for the train tomorrow.", "it": "ComprerÃ² un biglietto per il treno domani."}`;
            
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: "You are a language learning API that generates structured JSON content." }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "en": { "type": "STRING" },
                            "it": { "type": "STRING" }
                        },
                        "propertyOrdering": ["en", "it"]
                    }
                }
            };

            let newPhrase = null;
            
            try {
                const response = await fetch(GEMINI_TEXT_API, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (jsonText) {
                    const parsedJson = JSON.parse(jsonText);
                    newPhrase = {
                        en: parsedJson.en,
                        it: parsedJson.it,
                        mastered: 0,
                        static: false // Mark as dynamic
                    };
                }
            } catch (error) {
                console.error('Error generating dynamic phrase:', error);
                showTutorSystemMessage("Failed to generate new phrase (API Error). Falling back to static content.");
            }

            isGeneratingPhrase = false;
            if (newPhrase) {
                // Ensure the phrase is unique before adding
                if (!currentPhrases.some(p => p.en === newPhrase.en)) {
                    currentPhrases.push(newPhrase);
                    saveProgress(currentPhrases);
                    showTutorSystemMessage("New Dynamic Phrase Added! Challenge increased.");
                }
            }
            
            // Force re-select to get the new or a fallback phrase
            await selectNewPhrase(true);
        }
        
        function selectNewPhrase(wasDynamic = false) {
            // CRITICAL SAFETY CHECK: Ensure phrases are loaded before attempting selection
            if (currentPhrases.length === 0) {
                 // Initialize with base phrases if they haven't been loaded by setupFirebase yet
                 currentPhrases = languageSelect.value === 'italian' 
                    ? [...baseItalianPhrases] 
                    : [...baseSicilianPhrases];
                 
                 if (currentPhrases.length === 0) {
                    phraseEnElement.textContent = "Loading error: No phrases available.";
                    wordBankElement.innerHTML = '';
                    tutorFeedbackElement.textContent = 'Please refresh or check console for errors.';
                    console.error("selectNewPhrase aborted: No phrases available in phraseSet.");
                    return; 
                 }
            }


            // Check current level to decide whether to generate a new phrase
            const staticMastered = currentPhrases.filter(p => p.static && p.mastered >= masteredThreshold).length;
            const staticTotal = baseItalianPhrases.length;
            const level = staticMastered / staticTotal; // 0.0 to 1.0

            const unmasteredPhrases = currentPhrases.filter(p => p.mastered < masteredThreshold);
            
            let phraseSet = unmasteredPhrases;

            // 1. Dynamic Generation Logic
            if (!wasDynamic && level >= 0.5 && Math.random() < 0.3) { // 30% chance to generate new phrase after 50% static mastery
                let levelText = 'Intermediate';
                if (level >= 0.8) levelText = 'Advanced';

                // Check if we already have too many unmastered dynamic phrases
                const unmasteredDynamic = currentPhrases.filter(p => !p.static && p.mastered < masteredThreshold).length;
                
                if (unmasteredDynamic < 10) { // Limit unmastered dynamic phrases to prevent overload
                    generateDynamicPhrase(languageSelect.value, levelText);
                    return; // Return early, the generation function will call selectNewPhrase(true) when done.
                }
            }
            
            // 2. Fallback/Selection Logic
            if (phraseSet.length === 0) {
                // If all are mastered, reset everything
                currentPhrases.forEach(p => p.mastered = 0);
                saveProgress(currentPhrases); 
                showTutorSystemMessage("You have mastered all current phrases! Starting the review cycle.");
                phraseSet = currentPhrases;
            }

            // Prioritize phrases that need penalty practice (mastered < 0)
            const phrasesToRepeat = phraseSet.filter(p => p.mastered < 0);
            
            currentPhrase = phrasesToRepeat.length > 0 
                ? phrasesToRepeat[Math.floor(Math.random() * phrasesToRepeat.length)]
                : phraseSet[Math.floor(Math.random() * phraseSet.length)];

            // Set UI
            phraseEnElement.textContent = currentPhrase.en;
            renderMastery();

            // Prepare words for the bank
            const correctWords = currentPhrase.it.split(/[\s,.'â€™]+/g).filter(w => w.length > 0);
            let allWords = [...correctWords];

            // Add 3 Distractor words
            const allTargetWords = (currentPhrases.flatMap(p => p.it.split(/[\s,.'â€™]+/g))).filter(w => w.length > 2);
            let distractors = [];
            while (distractors.length < 3) {
                const randomWord = allTargetWords[Math.floor(Math.random() * allTargetWords.length)];
                // Check if it's not a correct word and not already a distractor
                if (!correctWords.map(w => w.toLowerCase()).includes(randomWord.toLowerCase()) && !distractors.includes(randomWord)) {
                    distractors.push(randomWord);
                }
            }
            
            allWords = allWords.concat(distractors);
            allWords.sort(() => Math.random() - 0.5);
            
            // Render the UI
            renderWordBank(allWords);
            tutorFeedbackElement.textContent = '';
            nextBtn.classList.add('hidden');
            checkBtn.classList.remove('hidden');
            checkButtonState();
        }

        // --- Firebase Handlers ---
        async function saveProgress(phrases) {
            // Check if DB is initialized before attempting to save
            if (!db || !userId) return console.error("Database not ready, cannot save progress.");
            try {
                // Stringify the entire phrase array for simple saving
                const progressData = { phrases: JSON.stringify(phrases), timestamp: new Date().toISOString() };
                await setDoc(progressDocRef(), progressData, { merge: true });
            } catch (error) {
                console.error("Error saving progress:", error);
            }
        }
        
        async function loadProgress() {
            // Check if DB is initialized before attempting to load
            if (!db || !userId) return;

            // 1. Set the initial phrase list (Base static phrases)
            currentPhrases = languageSelect.value === 'italian' 
                ? [...baseItalianPhrases] 
                : [...baseSicilianPhrases];

            try {
                const docSnap = await getDoc(progressDocRef());
                if (docSnap.exists() && docSnap.data().phrases) {
                    const savedPhrases = JSON.parse(docSnap.data().phrases);
                    
                    // 2. Merge saved dynamic and static phrases
                    const baseStaticMap = new Map(currentPhrases.map(p => [p.en, p]));
                    
                    savedPhrases.forEach(savedP => {
                        if (savedP.static && baseStaticMap.has(savedP.en)) {
                            // Update mastery for static phrases
                            baseStaticMap.get(savedP.en).mastered = savedP.mastered;
                        } else if (!savedP.static) {
                            // Add all dynamic phrases back
                            baseStaticMap.set(savedP.en, savedP);
                        }
                    });

                    // Update the global list with the merged/updated set
                    currentPhrases = Array.from(baseStaticMap.values());
                    
                    showTutorSystemMessage("Progress loaded successfully!");
                } else {
                    showTutorSystemMessage("No existing progress found. Starting new session.");
                }
            } catch (error) {
                console.error("Error loading progress:", error);
                showTutorSystemMessage("Error loading progress. Using default phrases.");
            }
        }

        async function saveChatHistory() {
            // Check if DB is initialized before attempting to save
            if (!db || !userId) return console.error("Database not ready, cannot save chat.");
            try {
                await setDoc(chatHistoryDocRef(), { history: JSON.stringify(chatHistory) });
            } catch (error) {
                console.error("Error saving chat history:", error);
            }
        }

        async function loadChatHistory() {
            if (!db || !userId) {
                renderChatHistory(); // Render empty history if DB is not ready
                return;
            }
            try {
                const docSnap = await getDoc(chatHistoryDocRef());
                if (docSnap.exists()) {
                    chatHistory = JSON.parse(docSnap.data().history);
                } else {
                    chatHistory = [];
                }
                renderChatHistory();
            } catch (error) {
                console.error("Error loading chat history:", error);
            }
        }
        
        function renderChatHistory() {
            chatWindow.innerHTML = '';
            chatHistory.forEach(message => {
                appendChatMessage(message.text, message.sender);
            });
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        // --- Gemini Chat Handlers ---
        async function getTutorResponse(userMessage) {
            if (isWaitingForResponse) return;
            isWaitingForResponse = true;

            appendChatMessage(userMessage, 'user');
            chatHistory.push({ text: userMessage, sender: 'user' });
            chatInput.value = '';
            chatInput.placeholder = "Tutor is typing...";

            const targetLang = languageSelect.value === 'italian' ? 'Italian' : 'Sicilian';
            const prompt = `You are a conversational language tutor for ${targetLang}. Respond naturally and encouragingly in the target language. Keep the response simple and helpful for a learner. Do not provide an English translation unless the user asks for it explicitly.`;
            
            const payload = {
                contents: chatHistory.map(msg => ({
                    role: msg.sender === 'user' ? 'user' : 'model',
                    parts: [{ text: msg.text }]
                })),
                systemInstruction: { parts: [{ text: prompt }] },
                generationConfig: { temperature: 0.8, maxOutputTokens: 100, },
            };

            let responseText = "Sorry, I couldn't get a response. The Gemini API Key is missing or invalid.";
            if (API_KEY === "") {
                appendChatMessage(responseText, 'model');
                isWaitingForResponse = false;
                chatInput.placeholder = "Send a message...";
                return;
            }

            try {
                const response = await fetch(GEMINI_TEXT_API, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                if (result.candidates && result.candidates[0] && result.candidates[0].content) {
                    responseText = result.candidates[0].content.parts[0].text;
                } else if (result.error) {
                    responseText = `API Error: ${result.error.message}. Please check that your Gemini key is valid and not restricted.`;
                }
            } catch (error) {
                console.error('Error with Gemini text generation:', error);
                responseText = "Sorry, I couldn't connect to the Gemini API. Check your network or API key settings.";
            }

            appendChatMessage(responseText, 'model');
            chatHistory.push({ text: responseText, sender: 'model' });
            saveChatHistory();
            if (!responseText.startsWith("Error:") && !responseText.startsWith("Sorry,")) {
                speakText(responseText);
            }
            isWaitingForResponse = false;
            chatInput.placeholder = "Send a message...";
        }

        // --- Main App Initialization ---
        function startAppLogic() { 
            updateFlag();
            // Load progress and then select phrase and update UI
            loadProgress().then(() => {
                selectNewPhrase();
                updateProgressBar();
            });
        }

        async function setupFirebase() {
            // Check if firebaseConfig is minimally populated before attempting init
            const configKeys = Object.keys(firebaseConfig);
            if (configKeys.length === 0 || !firebaseConfig.apiKey) {
                console.error("FATAL FIREBASE CONFIG ERROR: Firebase config is missing or invalid. App will run in non-persistent mode.");
                userIdDisplay.textContent = "ATTENZIONE: Nessuna persistenza dati (Firebase non configurato).";
                startAppLogic();
                return; // Exit early, running in non-persistent mode
            }
            
            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                // IMPORTANT: Wait for auth state to be resolved before proceeding
                await new Promise((resolve) => {
                    const unsubscribe = onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            userIdDisplay.textContent = `User ID: ${userId}`;
                            unsubscribe();
                            resolve();
                        } else {
                            // Use custom token if available, otherwise sign in anonymously
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                        }
                    });
                });

                startAppLogic();

            } catch (error) {
                console.error("FATAL FIREBASE INITIALIZATION ERROR:", error);
                userIdDisplay.textContent = `FATAL ERROR: Firebase Initialization Failed (${error.code}). Non-persistent mode active.`;
                showTutorSystemMessage("Errore critico di inizializzazione Firebase. Proseguo in modalitÃ  non persistente.");
                // Ensure logic starts even if Firebase failed, just without DB/Auth features
                auth = null;
                db = null;
                userId = crypto.randomUUID(); // Set a dummy ID for internal logic
                startAppLogic(); 
            }
        }
        
        // --- Event Listeners Setup ---
        tutorModeBtn.addEventListener('click', () => switchMode('tutor'));
        chatModeBtn.addEventListener('click', () => switchMode('chat'));

        languageSelect.addEventListener('change', (e) => {
            if (chatSection.classList.contains('hidden')) {
                // In tutor mode, reload phrases and start new session
                startAppLogic();
            } else {
                // In chat mode, just load the chat history for the new language
                loadChatHistory();
                updateFlag();
            }
        });

        checkBtn.addEventListener('click', () => {
            if (!currentPhrase) return showTutorSystemMessage("The tutor is not ready yet.");

            const sentenceWords = Array.from(currentSentenceElement.children).map(btn => btn.textContent.trim());
            
            // Normalize for comparison
            const userAnswer = sentenceWords.join(' ')
                .replace(/\s([.,?!:;])/g, '$1')
                .toLowerCase();
            
            const correctAnswer = currentPhrase.it
                .replace(/\s([.,?!:;])/g, '$1')
                .toLowerCase()
                .replace(/'|â€™/g, "'"); 
                
            const normalizedUserAnswer = userAnswer.replace(/'|â€™/g, "'");

            if (normalizedUserAnswer === correctAnswer) {
                tutorFeedbackElement.textContent = "Correct! Great job!";
                tutorFeedbackElement.style.color = '#10B981';
                checkBtn.classList.add('hidden');
                nextBtn.classList.remove('hidden');
                
                Array.from(currentSentenceElement.children).forEach(btn => {
                    btn.classList.add('bg-green-500', 'text-white', 'hover:bg-green-600');
                    btn.classList.remove('bg-blue-500', 'hover:bg-blue-500');
                    btn.disabled = true;
                });

                currentPhrase.mastered++;
                saveProgress(currentPhrases);
                updateProgressBar();
            } else {
                tutorFeedbackElement.textContent = "That's not quite right. Try re-arranging the words!";
                tutorFeedbackElement.style.color = '#EF4444';
                
                if (currentPhrase.mastered > 0) currentPhrase.mastered = 0;
                if (currentPhrase.mastered === 0) currentPhrase.mastered = -1;
                saveProgress(currentPhrases);
                updateProgressBar();
            }
            renderMastery();
        });

        nextBtn.addEventListener('click', () => selectNewPhrase());

        revealBtn.addEventListener('click', () => {
            if (!currentPhrase) return showTutorSystemMessage("The tutor is not ready yet.");

            tutorFeedbackElement.textContent = `The correct answer is: "${currentPhrase.it}"`;
            tutorFeedbackElement.style.color = '#4B5563';
            checkBtn.classList.add('hidden');
            nextBtn.classList.remove('hidden');
            
            wordBankElement.classList.add('opacity-0');
            Array.from(currentSentenceElement.children).forEach(btn => btn.disabled = true);

            currentPhrase.mastered = -1;
            saveProgress(currentPhrases);
            renderMastery();
            updateProgressBar();
        });

        tutorListenBtn.addEventListener('click', () => {
            if (!currentPhrase) return showTutorSystemMessage("The tutor is not ready yet.");
            speakText(currentPhrase.it);
        });

        chatSendBtn.addEventListener('click', () => {
            const userMessage = chatInput.value.trim();
            if (userMessage) {
                getTutorResponse(userMessage);
            }
        });

        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                chatSendBtn.click();
            }
        });

        // Initial calls
        setupFirebase();
    </script>
</body>
</html>